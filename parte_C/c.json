{
	"main": {
		"prefix": "main",
		"body": [
			"",
			"int main(int argc, char **argv) {",
			"    $1",
			"    exit(0);",
			"}"
		],
		"description": "Main function"
	},
	"librerie": {
		"prefix": "lib",
		"body": [
			"/* File ${TM_FILENAME} */",
			"/* Standard C = C11 */",
			"",
			"#include <stdio.h> /* Standard I/O: printf, BUFSIZ */",
			"#include <fcntl.h> /* File CoNTrol: open, O_RDONLY, O_WRONLY, O_RDWR */",
			"#include <stdlib.h> /* STanDard LIBrary: exit, malloc, calloc, free, atoi */",
			"#include <unistd.h> /* UNIx Standard: read, write, close, SEEK_SET, SEEK_CUR, SEEK_END */",
			"#include <string.h> /* STRING: strlen, strcpy, strcmp */",
			"#include <sys/stat.h> /* SYStem STATus: stat, fstat, S_IFMT, S_IFDIR, S_IFREG */",
			"#include <sys/wait.h> /* SYStem WAIT: wait */",
			"#include <sys/types.h> /* SYStem TYPES: pid_t */",
			"",
			"typedef int pipe_t[2]; /* Definizione di un tipo pipe_t come array di 2 interi */"

		],
		"description": "Libraries"
	},


	"printf": {
		"prefix": "printf",
		"body": [
			"printf(\"$1\\n\");"
		],
		"description": "Print to console"
	},

	"for":{
		"prefix": "for",
		"body": [
			"for (int ${1:i} = 0; ${1:i} < $2; ${1:i}++) {",
			"    $3",
			"}"
		],
		"description": "For loop"
	},
	"if": {
		"prefix": "if",
		"body": [
			"if ($1) {",
			"    $2",
			"}"
		],
		"description": "If statement"
	},
	"else": {
		"prefix": "else",
		"body": [
			"else {",
			"    $1",
			"}"
		],
		"description": "Else statement"
	},
	"else if": {
		"prefix": "elif",
		"body": [
			"else if ($1) {",
			"    $2",
			"}"
		],
		"description": "Else if statement"
	},
	"while": {
		"prefix": "while",
		"body": [
			"while ($1) {",
			"    $2",
			"}"
		],
		"description": "While loop"
	},
	"Struct": {
		"prefix": "structEsempio",
		"body": [
		  "typedef struct{",
		  "    int c1;",
		  "    int c2;",
		  "    char c3[250];",
		  "} msg;"
		],
		"description": "Struct"
	},
	"switch": {
		"prefix": "switch",
		"body": [
			"switch ($1) {",
			"    case $2:",
			"        $3",
			"        break;",
			"    default:",
			"        $4",
			"        break;",
			"}"
		],
		"description": "Switch statement"
	},
	"Controllo che sia file": {
		"prefix": "file",
		"body": [
			"/* controllo che il ${2:XXXX} parametro sia un file */",
			"",
			"int fd1; /* variabile per valore di ritorno open */",
			"if ((fd1 = open(argv[$1], O_RDONLY)) < 0) {",
			"    printf(\"Errore in apertura file per '%s' -> FILE NON ESISTE\\n\", argv[$1]);",
			"    exit(${3:0000});",
			"}",
			"close(fd1);",
			"$4"
		],
		"description": "Controllo che sia file"
	},

	"Controllo che sia singolo carattere": { 
		"prefix": "singolo", 
		"body": [ 
			"/* controllo che il ${2:XXXX} parametro sia un singolo carattere */", 
			"if (argv[$1][1] != '\\0') {", 
			"\tprintf(\"Error: %s non singolo carattere\\n\", argv[$1]);", 
			"\texit(${3:0000});", 
			"}", 
			"char ${4:C} = argv[$1][0];" ], 
		"description": "Controllo che sia singolo carattere" 
	},
	"Leggi tutto un file carattere per carattere": {
		"prefix": "leggiFileCaratterePerCarattere",
		"body": [
			"/* leggi tutto il file */",
			"char c;",
			"while (read(${1:file}, &c, 1)) {",
			"    printf(\"%c\", c);",
			"}"
		],
		"description": "Leggi tutto un file carattere per carattere"
	},

	"Leggi e trasforma file": {
		"prefix": "leggiTrasformaFile",
		"body": [
			"/* Leggo il file carattere per carattere */",
			"while (read(fd, &ch, 1)) {",
			"    /* controlliamo se abbiamo trovato un carattere alfabetico minuscolo */",
			"    if (islower(ch)) {",
			"        /* trasformiamo il carattere in maiuscolo */",
			"        ch = toupper(ch);",
			"        /* ci posizioniamo all'inizio del carattere da sovrascrivere */",
			"        lseek(fd, -1L, SEEK_CUR);",
			"        /* sovrascriviamo il carattere */",
			"        write(fd, &ch, 1);",
			"        /* incrementiamo il contatore delle trasformazioni */",
			"        trasformazioni++;",
			"    }",
			"}"
		],
		"description": "Leggi e trasforma file"
	},
	
	"Controllo numero parametri":{
		"prefix": "numeroParametri",
		"body": [
			"/* controllo numero parametri */",
			"if (argc != $1) {",
			"    printf(\"Error: numero parametri '%d' errato\\n\", argc - 1);",
			"\tprintf(\"Uso: %s $2\\n\", argv[0]);",
			"    exit(${3:0000});",
			"}"
		],
		"description": "Controllo numero parametri"
	},

	"variabili locali":{
		"prefix": "variabiliLocali",
		"body": [
			"/* -------- Variabili locali ---------- */",
			"int pid;                \t\t/* process identifier per le fork() */",
			"int N;                  \t\t/* numero di file passati sulla riga di comando (uguale al numero di file) */",
			"pipe_t *piped;          \t\t/* array dinamico di pipe descriptors per comunicazioni figli-padre  */",
			"pipe_t p;               \t\t/* una sola pipe per ogni coppia figlio-nipote */",
			"int i, j;               \t\t/* indici per i cicli */",
			"int pidFiglio, status, ritorno;\t/* per valore di ritorno figli */",
			"$1",
			"/* ------------------------------------ */"
		],
		"description": "Variabili locali"
	},
	
	"Controllo che sia un numero strettamente positivo":{
		"prefix": "numeroPositivo",
		"body": [
			"/* controllo che il ${2:XXXX} parametro sia un numero strettamente positivo */",
			"int num = atoi(argv[$1]);",
			"if (num <= 0) {",
			"    printf(\"Error: %s non e' un numero strettamente positivo\\n\", argv[$1]);",
			"    exit(${3:0000});",
			"}"
		],
		"description": "Controllo che sia un numero strettamente positivo"
	},
	"creazione di N pipe":{
		"prefix": "creaPipe",
		"body": [
			"/* Creazione di N pipe */",
			"if ((piped = (pipe_t *) malloc(N * sizeof(pipe_t))) == NULL) {",
			"    printf(\"Errore allocazione pipe\\n\");",
			"    exit(${1:0000});",
			"}",
			"for (i = 0; i < N; i++) {",
			"    if (pipe(piped[i]) < 0) {",
			"        printf(\"Errore creazione pipe\\n\");",
			"        exit(${2:0000});",
			"    }",
			"}"
		],
		"description": "creazione di N pipe"
	
	},
	"gestione completa figlio": {
		"prefix": "figlio",
		"body": [
			"int pid, pidFiglio; /* pid per fork e pidFiglio per wait */",
			"int pidPadre = getpid();",
			"printf(\"La pid del padre e': %d\\n\", pidPadre);",
			"if ((pid = fork()) < 0) {",
			"    //Fork fallita",
			"    printf(\"Errore in fork\\n\");",
			"    exit(${1:EXITCODE});",
			"}",
			"",
			"if (pid == 0) {",
			"    /* CODICE DEL FIGLIO*/",
			"",
			"    exit(CODICEDUSCITA);",
			"",
			"    /*FINE CODICE DEL FIGLIO*/",
			"}",
			"",
			"/* padre */",
			"printf(\"Generato figlio con PID = %d\\n\", pid);",
			"/* Il padre aspetta il figlio salvando lo status */",
			"int status;",
			"if ((pidFiglio = wait(&status)) < 0){",
			"    /* La wait non ha avuto successo */",
			"    printf(\"Errore in wait\\n\");",
			"    exit(${2:EXITCODE});",
			"}",
			"",
			"/* Se il pid ritornato dalla wait e' corretto */",
			"if (pid == pidFiglio) {",
			"    printf(\"Terminato figlio con PID = %d\\n\", pidFiglio);",
			"    if (WIFEXITED(status)) {",
			"        /* Ricavo l'exitcode del figlio con la funzione WEXITSTATUS */",
			"        printf(\"Il figlio e' ritornato con codice: %d\\n\", WEXITSTATUS(status));",
			"    } else {",
			"        /* Lo status riporta una terminazione anomala */",
			"        printf(\"Il figlio e' terminato in modo anomalo\\n\");",
			"    }",
			"} else {",
			"    /* Il pid non corrisponde con il figlio aspettato */",
			"    printf(\"Il pid della wait non corrisponde al pid della fork!\\n\");",
			"    exit(${3:EXITCODE});",
			"}"
		],
		"description": "gestione completa figlio"
	},
	"Creazione di N figli":{
		"prefix": "figliN",
		"body": [
			"printf(\"La pid del padre e' %d, deve generare %d figli: %d\\n\", getpid(), N);",
			"",
			"/* Per la creazione di N figli */",
			"for(int i = 0; i < N; i++) {",
			"    if ((pid = fork()) < 0) {",
			"        /* Fork fallita */",
			"        printf(\"Errore in fork per il figlio %d-esimo\\n\", i);",
			"        exit(${1:ERRORE});",
			"    }",
			"    ",
			"    if (pid == 0) {",
			"        /* CODICE DEL FIGLIO*/",
			"",
			"        printf(\"Figlio, pid: %d, indice %d\\n\", getpid(), i);",
			"        exit(EXITCODEFIGLIO);",
			"",
			"        /*FINE CODICE DEL FIGLIO*/",
			"    }",
			"    printf(\"Generato figlio con PID = %d\\n\", pid);",
			"}",
			"",
			"/* padre */",
			"",
			"/* Il padre aspetta i figli salvando lo status */",
			"for(int i = 0; i < N; i++) {",
			"    if ((pidFiglio = wait(&status)) < 0) {",
			"        /* La wait non ha avuto successo */",
			"        printf(\"Errore in wait\\n\");",
			"        exit(${2:ERRORE});",
			"    }",
			"",
			"    printf(\"Terminato figlio con PID = %d\\n\", pidFiglio);",
			"    if (WIFEXITED(status)) {",
			"        /* Ricavo l'exitcode del figlio con la funzione WEXITSTATUS */",
			"        ritorno = WEXITSTATUS(status);",
			"        printf(\"Il figlio %d-esimo e' ritornato con codice: %d\\n\", ritorno);",
			"    } else {",
			"        /* Lo status riporta una terminazione anomala */",
			"        printf(\"Il figlio %d-esimo e' terminato in modo anomalo\\n\", i);",
			"    }",
			"}"
		],
		"description": "Creazione di N figli"
	},
	"chiusura pipe figlio": {
		"prefix": "chiusuraPipeFiglio",
		"body": [
			"/* chiusura di tutte le pipe che il figlio non usa */",
			"for(j = 0; j < N; j++) {",
			"    if (j != i)",
			"        close(piped[j][1]);",
			"    if ((i == 0) || (j != i-1))",
			"        close(piped[j][0]);",
			"}"
		],
		"description": "Chiusura pipe figlio"
	},

	"creazione multipli figli N con salvataggio PID": {
		"prefix": "figliNConSalvataggioPID",
		"body": [
			"printf(\"La pid del padre e' :%d\\n\", pidPadre);",
			"",
			"pid_t *pidDeiFigli = malloc(N*sizeof(pid_t));",
			"",
			"if(pidDeiFigli == NULL) {",
			"    printf(\"Errore nell'allocazione della memoria\\n\");",
			"    exit(${2:ERRORE});",
			"}",
			"",
			"/* Per la creazione di N figli */",
			"for(int i = 0; i < N; i++) {",
			"    if ((pid = fork()) < 0) {",
			"        /* Fork fallita */",
			"        printf(\"Errore in fork\\n\");",
			"        free(pidDeiFigli);",
			"        exit(${3:ERRORE});",
			"    }",
			"    ",
			"    if (pid == 0) {",
			"        /* CODICE DEL FIGLIO*/",
			"",
			"        printf(\"Figlio, pid: %d, indice %d\\n\", getpid(), i);",
			"        exit(EXITCODEFIGLIO);",
			"",
			"        /*FINE CODICE DEL FIGLIO*/",
			"    }",
			"    printf(\"Generato figlio con PID = %d\\n\", pid);",
			"    pidDeiFigli[i] = pid;",
			"}",
			"",
			"/* padre */",
			"pid_t pidFiglio;",
			"int status, ritorno;",
			"/* Il padre aspetta i figli salvando lo status */",
			"for(int i = 0; i < N; i++) {",
			"    if ((pidFiglio = wait(&status)) < 0) {",
			"        /* La wait non ha avuto successo */",
			"        printf(\"Errore in wait\\n\");",
			"        free(pidDeiFigli);",
			"        exit(${4:ERRORE});",
			"    }",
			"",
			"    int posizione = 0;",
			"    for(int j = 0; j < N; j++) {",
			"        if(pidDeiFigli[j] == pidFiglio){",
			"            posizione = j;",
			"            break;",
			"        }",
			"    }",
			"    /* Posizione partendo da 0 */",
			"    printf(\"Terminato figlio con PID = %d, creato per %d-esimo\\n\", pidFiglio, posizione);",
			"    if (WIFEXITED(status)) {",
			"        /* Ricavo l'exitcode del figlio con la funzione WEXITSTATUS */",
			"        ritorno = WEXITSTATUS(status);",
			"        printf(\"Il figlio e' ritornato con codice: %d\\n\", ritorno);",
			"    } else {",
			"        /* Lo status riporta una terminazione anomala */",
			"        printf(\"Il figlio e' terminato in modo anomalo\\n\");",
			"    }",
			"}",
			"/* Libero la memoria dove ho salvato i PID dei figli */",
			"free(pidDeiFigli);"
		],
		"description": "creazione multipli figli N con salvataggio PID"
	},
	"Pid Padre":{ 
		"prefix": "pidProcessoCorrentePadre", 
		"body": [ 
			"int pidPadre = getpid();", 
			"printf(\"La pid del padre e': %d\\n\", pidPadre);" 
		], 
		"description": "Ritorna il Pid Padre del processo corrente" 
	},
	"conta numero di caratteri uguali a Cx in file": {
		"prefix": "contaCharUgualiACx",
		"body": [
			"//Ritorna il numero di occorrenze del carattere Cx nel file F",
			"long int contaOccorrenzeCarattere(const char *F, char Cx){",
			"    /* Apertura file */",
			"    int fd, n;",
			"    if((fd = open(F, O_RDONLY)) < 0){",
			"        printf(\"Errore: impossibile aprire il file %s\\n\", F);",
			"        exit(${1:EXITCODE});",
			"    }",
			"    char buffer;",
			"    long int occorrenze = 0;",
			"    /* Lettura file carattere per carattere */",
			"    while((n = read(fd, &buffer, 1)) > 0){",
			"        if(buffer == Cx){",
			"            occorrenze++;",
			"        }",
			"    }",
			"    printf(\"Il carattere %c compare %ld volte nel file %s\\n\", Cx, occorrenze, F);",
			"    close(fd);",
			"    return occorrenze;",
			"}"
		],
		"description": "conta numero di caratteri uguali  a Cx in file"
	},
	"Crea figlio": {
		"prefix": "creaFiglio",
		"body": [
			"if ((pid = fork()) < 0) {",
			"    /* Fork fallita */",
			"    printf(\"Errore in fork\\n\");",
			"    exit(${1:0000});",
			"}",
			"",
			"if (pid == 0) {",
			"    /* CODICE DEL FIGLIO*/",
			"",
			"    printf(\"Figlio, pid: %d, indice %d\\n\", getpid(), i);",
			"    exit(EXITSON);",
			"",
			"    /* FINE CODICE DEL FIGLIO */",
			"}",
			"printf(\"Generato figlio con PID = %d\\n\", pid);"
		],
		"description": "Crea figlio"
	},
	"Wait padre": {
        "prefix": "waitPadre",
        "body": [
			"/* Il padre aspetta i figli salvando lo status */",
            "for (int i = 0; i < N; i++) {",
            "    if ((pidFiglio = wait(&status)) < 0) {",
            "        printf(\"Errore in wait\\n\");",
            "        exit(5);",
            "    }",
            "    if ((status & 0xFF) != 0)",
            "        printf(\"Figlio con pid %d terminato in modo anomalo\\n\", pidFiglio);",
            "    else {",
            "        ritorno = (int)((status >> 8) & 0xFF);",
            "        printf(\"Il figlio con pid=%d ha ritornato il carattere %c (in decimale %d, se 255 problemi)\\n\", pidFiglio, ritorno, ritorno);",
            "    }",
            "}"
        ],
        "description": "Wait padre"
    },

	"debug":{ 
		"prefix": "debug", 
		"body": [ 
			"printf(\"--------------------------\\n\");",
			"printf(\"DEBUG: $1\\n\");",
			"printf(\"--------------------------\\n\");"
		], 
		"description": "Debug" 
	},

	"error":{ 
		"prefix": "error", 
		"body": [ 
			"printf(\"##################################################\\n\");",
			"printf(\"Error: $1\\n\");",
			"printf(\"##################################################\\n\");",
			"exit(${2:EXITCODE});"
		], 
		"description": "Error" 
	},
	"Pipeline figlio-padre": {
		"prefix": "figlio-padre",
		"body": [
		  "/* File 12Set18.c */",
		  "/* Standard C = C11 */",
		  "",
		  "#include <stdio.h> /* Standard I/O: printf, BUFSIZ */",
		  "#include <fcntl.h> /* File CoNTrol: open, O_RDONLY, O_WRONLY, O_RDWR */",
		  "#include <stdlib.h> /* STanDard LIBrary: exit, malloc, calloc, free, atoi */",
		  "#include <unistd.h> /* UNIx Standard: read, write, close, SEEK_SET, SEEK_CUR, SEEK_END */",
		  "#include <sys/wait.h> /* SYStem WAIT: wait */",
		  "",
		  "typedef int pipe_t[2]; /* Definizione di un tipo pipe_t come array di 2 interi */",
		  "",
		  "",
		  "int main(int argc, char const **argv) {",
		  "    /* controllo numero parametri */",
		  "    if (argc != 3) {",
		  "        printf(\"Error: numero parametri '%d' errato\\n\", argc - 1);",
		  "        printf(\"Uso: %s \\n\", argv[0]);",
		  "        exit(1);",
		  "    }",
		  "",
		  "    /* -------- Variabili locali ---------- */",
		  "    int pid;                \t\t\t/* process identifier per le fork() */",
		  "    int N;                  \t\t\t/* numero di file passati sulla riga di comando (uguale al numero di file) */",
		  "    pipe_t *piped;          \t\t\t/* array dinamico di pipe descriptors per comunicazioni figli-padre  */",
		  "    int i, j;               \t\t\t/* indici per i cicli */",
		  "    int pidWaitedSon, status, ritorno;\t/* per valore di ritorno dei vari processi (figli/nipoti) */",
		  "    int fd;              \t\t\t\t/* file descriptor */",
		  "    ",
		  "    /* ------------------------------------ */",
		  "",
		  "    /* Salvo il numero dei file in una variabile */",
		  "    N = argc - 1; ",
		  "",
		  "    /* Alloco memoria per l'array delle pipe per la comunicazione figlio-padre */",
		  "    if(!(piped = (pipe_t*) malloc(N * sizeof(pipe_t)))) {",
		  "        printf(\"Errore: Impossibile allocare memoria per l'array delle pipe per la comunicazione figlio-padre!\\n\");",
		  "        exit(2);",
		  "    }",
		  "",
		  "    /* Inizializzo l'array delle pipe */",
		  "    for(i = 0; i < N; i++) {",
		  "        if(pipe(piped[i]) < 0) {",
		  "            printf(\"Errore: Impossibile inizializzare l'array delle pipe, si è bloccato alla pipe di indice: %d!\\n\", i);",
		  "            exit(3);",
		  "        }",
		  "    }",
		  "",
		  "    printf(\"--------------------------\\n\");",
		  "    printf(\"DEBUG: Sono il padre con pid=%d e sto per creare [%d] figli!\\n\", getpid(), N);",
		  "    printf(\"--------------------------\\n\");",
		  "",
		  "    /* Creo N processi figli */",
		  "    for(i = 0; i < N; i++) {",
		  "",
		  "        if((pid = fork()) < 0) {",
		  "            printf(\"Errore: Impossibile creare il processo figlio %d-esimo!\\n\", i);",
		  "            exit(4);",
		  "        }",
		  "",
		  "        /* Codice del processo figlio */",
		  "        if(pid == 0) {",
		  "",
		  "            /* Chiudo tutte le pipe di non interesse */",
		  "            for(j = 0; j < N; j++) {",
		  "                close(piped[j][0]);",
		  "                if(i != j)",
		  "                    close(piped[j][1]);",
		  "            }",
		  "",
		  "            /*###############son operation###################*/",
		  "",
		  "            exit(0); /* return del figlio al padre */",
		  "        }",
		  "    }",
		  "",
		  "    /* Codice del processo padre */",
		  "",
		  "    /* Chiudo tutte le pipe di non interesse */",
		  "    for(i = 0; i < N; i++) {",
		  "        close(piped[i][1]);",
		  "    }",
		  "    ",
		  "    /*###############father operation###################*/",
		  "",
		  "",
		  "",
		  "    /* Il padre aspetta i figli salvando lo status */",
		  "    for (int i = 0; i < N; i++) {",
		  "        if ((pidWaitedSon = wait(&status)) < 0) {",
		  "            printf(\"Errore in wait per il figlio %d-esimo!\\n\", i);",
		  "            exit(5);",
		  "        }",
		  "        if ((status & 0xFF) != 0)",
		  "            printf(\"Figlio %d-esimo con pid %d terminato in modo anomalo\\n\", i, pidWaitedSon);",
		  "        else {",
		  "            ritorno = (int)((status >> 8) & 0xFF);",
		  "            printf(\"--------------------------\\n\");",
		  "            printf(\"DEBUG: Il figlio %d-esimo con pid=%d ha ritornato %d (se 255 problemi)\\n\", i, pidWaitedSon, ritorno);",
		  "            printf(\"--------------------------\\n\");",
		  "        }",
		  "    }",
		  "",
		  "    exit(0); /* return del padre al sistema */",
		  "}"
		],
		"description": "Pipeline figlio-padre"
	},
	"Pipeline nipote-figlio-padre": {
		"prefix": "nipote-figlio-padre",
		"body": [
		  "/* File ${TM_FILENAME} */",
		  "/* Standard C = C11 */",
		  "",
		  "#include <stdio.h> /* Standard I/O: printf, BUFSIZ */",
		  "#include <fcntl.h> /* File CoNTrol: open, O_RDONLY, O_WRONLY, O_RDWR */",
		  "#include <stdlib.h> /* STanDard LIBrary: exit, malloc, calloc, free, atoi */",
		  "#include <unistd.h> /* UNIx Standard: read, write, close, SEEK_SET, SEEK_CUR, SEEK_END */",
		  "#include <sys/wait.h> /* SYStem WAIT: wait */",
		  "",
		  "typedef int pipe_t[2]; /* Definizione di un tipo pipe_t come array di 2 interi */",
		  "",
		  "",
		  "int main(int argc, char const **argv) {",
		  "    /* controllo numero parametri */",
		  "    if (argc != 3) {",
		  "        printf(\"Error: numero parametri '%d' errato\\n\", argc - 1);",
		  "        printf(\"Uso: %s \\n\", argv[0]);",
		  "        exit(1);",
		  "    }",
		  "",
		  "    /* -------- Variabili locali ---------- */",
		  "    int pid;                \t\t\t/* process identifier per le fork() */",
		  "    int N;                  \t\t\t/* numero di file passati sulla riga di comando (uguale al numero di file) */",
		  "    pipe_t *piped;          \t\t\t/* array dinamico di pipe descriptors per comunicazioni figli-padre  */",
		  "    pipe_t p;               \t\t\t/* una sola pipe per ogni coppia figlio-nipote */",
		  "    int i, j;               \t\t\t/* indici per i cicli */",
		  "    int pidWaitedSon, status, ritorno;\t/* per valore di ritorno dei vari processi (figli/nipoti) */",
		  "    int fd;              \t\t\t\t/* file descriptor */",
		  "    ",
		  "    /* ------------------------------------ */",
		  "",
		  "",
		  "    /* Salvo il numero dei file in una variabile */",
		  "    N = argc - 1; ",
		  "",
		  "    /* Alloco memoria per l'array delle pipe per la comunicazione figlio-padre */",
		  "    if(!(piped = (pipe_t*) malloc(N * sizeof(pipe_t)))) {",
		  "        printf(\"Errore: Impossibile allocare memoria per l'array delle pipe per la comunicazione figlio-padre!\\n\");",
		  "        exit(2);",
		  "    }",
		  "",
		  "    /* Inizializzo l'array delle pipe */",
		  "    for(i = 0; i < N; i++) {",
		  "        if(pipe(piped[i]) < 0) {",
		  "            printf(\"Errore: Impossibile inizializzare l'array delle pipe, si è bloccato alla pipe di indice: %d!\\n\", i);",
		  "            exit(3);",
		  "        }",
		  "    }",
		  "",
		  "    printf(\"--------------------------\\n\");",
		  "    printf(\"DEBUG: Sono il padre con pid=%d e sto per creare [%d] figli!\\n\", getpid(), N);",
		  "    printf(\"--------------------------\\n\");",
		  "",
		  "    /* Creo N processi figli */",
		  "    for(i = 0; i < N; i++) {",
		  "",
		  "        if((pid = fork()) < 0) {",
		  "            printf(\"Errore: Impossibile creare il processo figlio %d-esimo!\\n\", i);",
		  "            exit(4);",
		  "        }",
		  "",
		  "        /* Codice del processo figlio */",
		  "        if(pid == 0) {",
		  "",
		  "            /* Chiudo tutte le pipe di non interesse */",
		  "            for(j = 0; j < N; j++) {",
		  "                close(piped[j][0]);",
		  "                if(i != j)",
		  "                    close(piped[j][1]);",
		  "            }",
		  "",
		  "            /* creo la pipe per la comunicazione con il nipote */",
		  "            if(pipe(p) < 0) {",
		  "                printf(\"Errore: Impossibile creare la pipe di collegamento nipote-figlio con pid=%d del figlio %d-esimo!\\n\", getpid(), i);",
		  "                exit(-1);",
		  "            }",
		  "",
		  "            /* Genero il processo nipote e verifico che non ci siano errori */",
		  "            if((pid = fork()) < 0) {",
		  "                printf(\"Errore: Impossibile generare il processo nipote associato al processo figlio %d-esimo con pid=%d!\\n\", i, getpid());",
		  "                exit(-1);",
		  "            }",
		  "",
		  "            /* Codice del processo nipote */",
		  "            if(pid == 0) {",
		  "                /* Chiudo le pipe di non interesse del processo nipote */",
		  "                close(piped[i][1]);",
		  "                close(p[0]);",
		  "",
		  "                /*#########################nephew operation#########################*/",
		  "",
		  "                exit(0); /* return del nipote al figlio */",
		  "            }",
		  "",
		  "            /* Chiudo la pipe di non interesse */",
		  "            close(p[1]);",
		  "",
		  "            /*###############son operation###################*/",
		  "",
		  "",
		  "            /* Aspetto la terminazione del processo nipote */",
		  "            if ((pidWaitedSon = wait(&status)) < 0) {",
		  "                printf(\"Errore in wait per il nipote associato al figlio %d-esimo con pid=%d!\\n\", i, getpid());",
		  "                exit(-1);",
		  "            }",
		  "            if ((status & 0xFF) != 0)",
		  "                printf(\"Il nipote con pid %d terminato in modo anomalo\\n\", pidWaitedSon);",
		  "            else {",
		  "                ritorno = (int)((status >> 8) & 0xFF);",
		  "                printf(\"--------------------------\\n\");",
		  "                printf(\"DEBUG: Il nipote con pid=%d ha ritornato %d (se 255 problemi)\\n\", pidWaitedSon, ritorno);",
		  "                printf(\"--------------------------\\n\");",
		  "            }",
		  "",
		  "            exit(0); /* return del figlio al padre */",
		  "        }",
		  "    }",
		  "",
		  "    /* Codice del processo padre */",
		  "",
		  "    /* Chiudo tutte le pipe di non interesse */",
		  "    for(i = 0; i < N; i++) {",
		  "        close(piped[i][1]);",
		  "    }",
		  "    ",
		  "    /*###############father operation###################*/",
		  "",
		  "",
		  "",
		  "    /* Il padre aspetta i figli salvando lo status */",
		  "    for (int i = 0; i < N; i++) {",
		  "        if ((pidWaitedSon = wait(&status)) < 0) {",
		  "            printf(\"Errore in wait per il figlio %d-esimo!\\n\", i);",
		  "            exit(5);",
		  "        }",
		  "        if ((status & 0xFF) != 0)",
		  "            printf(\"Figlio %d-esimo con pid %d terminato in modo anomalo\\n\", i, pidWaitedSon);",
		  "        else {",
		  "            ritorno = (int)((status >> 8) & 0xFF);",
		  "            printf(\"--------------------------\\n\");",
		  "            printf(\"DEBUG: Il figlio %d-esimo con pid=%d ha ritornato %d (se 255 problemi)\\n\", i, pidWaitedSon, ritorno);",
		  "            printf(\"--------------------------\\n\");",
		  "        }",
		  "    }",
		  "",
		  "    exit(0); /* return del padre al sistema */",
		  "}"
		],
		"description": "Pipeline nipote-figlio-padre"
	  },
	  "Pipeline nipote+figlio-padre": {
		"prefix": "nipote+figlio-padre",
		"body": [
		  "/* File 12Set18.c */",
		  "/* Standard C = C11 */",
		  "",
		  "#include <stdio.h> /* Standard I/O: printf, BUFSIZ */",
		  "#include <fcntl.h> /* File CoNTrol: open, O_RDONLY, O_WRONLY, O_RDWR */",
		  "#include <stdlib.h> /* STanDard LIBrary: exit, malloc, calloc, free, atoi */",
		  "#include <unistd.h> /* UNIx Standard: read, write, close, SEEK_SET, SEEK_CUR, SEEK_END */",
		  "#include <sys/wait.h> /* SYStem WAIT: wait */",
		  "",
		  "typedef int pipe_t[2]; /* Definizione di un tipo pipe_t come array di 2 interi */",
		  "",
		  "",
		  "int main(int argc, char const **argv) {",
		  "    /* controllo numero parametri */",
		  "    if (argc != 3) {",
		  "        printf(\"Error: numero parametri '%d' errato\\n\", argc - 1);",
		  "        printf(\"Uso: %s \\n\", argv[0]);",
		  "        exit(1);",
		  "    }",
		  "",
		  "    /* -------- Variabili locali ---------- */",
		  "    int pid;                \t\t\t/* process identifier per le fork() */",
		  "    int N;                  \t\t\t/* numero di file passati sulla riga di comando (uguale al numero di file) */",
		  "    pipe_t *pipedFP;          \t\t\t/* array dinamico di pipe descriptors per comunicazioni figli-padre  */",
		  "    pipe_t *pipedNP;          \t\t\t/* array dinamico di pipe descriptors per comunicazioni nipoti-padre  */",
		  "    int i, j;               \t\t\t/* indici per i cicli */",
		  "    int pidWaitedSon, status, ritorno;\t/* per valore di ritorno dei vari processi (figli/nipoti) */",
		  "    int fd;              \t\t\t\t/* file descriptor */",
		  "    ",
		  "    /* ------------------------------------ */",
		  "",
		  "",
		  "    /* Salvo il numero dei file in una variabile */",
		  "    N = argc - 1; ",
		  "",
		  "    /* Alloco memoria per l'array delle pipe per la comunicazione figlio-padre */",
		  "    if(!(pipedFP = (pipe_t*) malloc(N * sizeof(pipe_t)))) {",
		  "        printf(\"Errore: Impossibile allocare memoria per l'array delle pipe per la comunicazione figlio-padre!\\n\");",
		  "        exit(2);",
		  "    }",
		  "",
		  "    /* Alloco memoria per l'array delle pipe per la comunicazione nipote-padre */",
		  "    if(!(pipedNP = (pipe_t*) malloc(N * sizeof(pipe_t)))) {",
		  "        printf(\"Errore: Impossibile allocare memoria per l'array delle pipe per la comunicazione nipote-padre!\\n\");",
		  "        exit(3);",
		  "    }",
		  "",
		  "    /* Inizializzo l'array delle pipe */",
		  "    for(i = 0; i < N; i++) {",
		  "        if(pipe(pipedFP[i]) < 0) {",
		  "            printf(\"Errore: Impossibile inizializzare l'array delle pipe per il figlio %d-esimo!\\n\", i);",
		  "            exit(4);",
		  "        }",
		  "        if(pipe(pipedNP[i]) < 0) {",
		  "            printf(\"Errore: Impossibile inizializzare l'array delle pipe per il nipote %d-esimo!\\n\", i);",
		  "            exit(5);",
		  "        }",
		  "    }",
		  "",
		  "    printf(\"--------------------------\\n\");",
		  "    printf(\"DEBUG: Sono il padre con pid=%d e sto per creare [%d] figli!\\n\", getpid(), N);",
		  "    printf(\"--------------------------\\n\");",
		  "",
		  "    /* Creo N processi figli */",
		  "    for(i = 0; i < N; i++) {",
		  "",
		  "        if((pid = fork()) < 0) {",
		  "            printf(\"Errore: Impossibile creare il processo figlio %d-esimo!\\n\", i);",
		  "            exit(6);",
		  "        }",
		  "",
		  "        /* Codice del processo figlio */",
		  "        if(pid == 0) {",
		  "",
		  "            /* Chiudo tutte le pipe di non interesse */",
		  "            for(j = 0; j < N; j++) {",
		  "                close(pipedFP[j][0]);",
		  "                if(i != j)",
		  "                    close(pipedFP[j][1]);",
		  "            }",
		  "",
		  "            /* Creo il processo nipote */",
		  "            if((pid = fork()) < 0) {",
		  "                printf(\"Errore: Impossibile creare il processo nipote!\\n\");",
		  "                exit(-1);",
		  "            }",
		  "",
		  "            /* Codice del processo nipote */",
		  "            if(pid == 0) {",
		  "                /* chiusura della pipe rimasta aperta di comunicazione fra figlio-padre che il nipote non usa */",
		  "                close(pipedFP[i][1]);",
		  "",
		  "                /* Chiudo tutte le pipe di non interesse */",
		  "                for(j = 0; j < N; j++) {",
		  "                    close(pipedNP[j][0]);",
		  "                    if(i != j)",
		  "                        close(pipedNP[j][1]);",
		  "                }",
		  "",
		  "                /*###############grandson operation###################*/",
		  "",
		  "                exit(0); /* return del nipote al figlio */",
		  "            }",
		  "",
		  "            /* le pipe usate dal nipote vanno chiuse TUTTE */",
		  "            for(j = 0; j < N; j++) {",
		  "                close(pipedNP[j][0]);",
		  "                close(pipedNP[j][1]);",
		  "            }",
		  "",
		  "            /*###############son operation###################*/",
		  "",
		  "            /* il figlio aspetta il nipote */",
		  "            if ((pidWaitedSon = wait(&status)) < 0) {",
		  "                printf(\"Errore in wait per il nipote %d-esimo con pid=%d!\\n\", i, getpid());",
		  "            }",
		  "            if ((status & 0xFF) != 0)",
		  "                printf(\"Nipote con pid %d terminato in modo anomalo\\n\", pidWaitedSon);",
		  "            else {",
		  "                ritorno = (int)((status >> 8) & 0xFF);",
		  "                printf(\"--------------------------\\n\");",
		  "                printf(\"DEBUG: Il Nipote %d-esimo con pid=%d ha ritornato %d (se 255 problemi)\\n\", i, pidWaitedSon, ritorno);",
		  "                printf(\"--------------------------\\n\");",
		  "            }",
		  "",
		  "            exit(0); /* return del figlio al padre */",
		  "        }",
		  "    }",
		  "",
		  "    /* Codice del processo padre */",
		  "",
		  "    /* Chiudo tutte le pipe di non interesse */",
		  "    for(i = 0; i < N; i++) {",
		  "        close(pipedFP[i][1]);",
		  "        close(pipedNP[i][1]);",
		  "    }",
		  "    ",
		  "    /*###############father operation###################*/",
		  "",
		  "",
		  "",
		  "    /* Il padre aspetta i figli salvando lo status */",
		  "    for (int i = 0; i < N; i++) {",
		  "        if ((pidWaitedSon = wait(&status)) < 0) {",
		  "            printf(\"Errore in wait per il figlio %d-esimo!\\n\", i);",
		  "            exit(7);",
		  "        }",
		  "        if ((status & 0xFF) != 0)",
		  "            printf(\"Figlio %d-esimo con pid %d terminato in modo anomalo\\n\", i, pidWaitedSon);",
		  "        else {",
		  "            ritorno = (int)((status >> 8) & 0xFF);",
		  "            printf(\"--------------------------\\n\");",
		  "            printf(\"DEBUG: Il figlio %d-esimo con pid=%d ha ritornato %d (se 255 problemi)\\n\", i, pidWaitedSon, ritorno);",
		  "            printf(\"--------------------------\\n\");",
		  "        }",
		  "    }",
		  "",
		  "    exit(0); /* return del padre al sistema */",
		  "}"
		],
		"description": "Pipeline nipote+figlio-padre"
	},
	
	"Figli con comunicazione tra figli, ultimo figlio con il padre": {
		"prefix": "figliConPipeFFeUltimoFP",
		"body": [
		  "/* File 12Set18.c */",
		  "/* Standard C = C11 */",
		  "",
		  "#include <stdio.h> /* Standard I/O: printf, BUFSIZ */",
		  "#include <fcntl.h> /* File CoNTrol: open, O_RDONLY, O_WRONLY, O_RDWR */",
		  "#include <stdlib.h> /* STanDard LIBrary: exit, malloc, calloc, free, atoi */",
		  "#include <unistd.h> /* UNIx Standard: read, write, close, SEEK_SET, SEEK_CUR, SEEK_END */",
		  "#include <sys/wait.h> /* SYStem WAIT: wait */",
		  "",
		  "typedef int pipe_t[2]; /* Definizione di un tipo pipe_t come array di 2 interi */",
		  "",
		  "",
		  "int main(int argc, char const **argv) {",
		  "    /* controllo numero parametri */",
		  "    if (argc != 3) {",
		  "        printf(\"Error: numero parametri '%d' errato\\n\", argc - 1);",
		  "        printf(\"Uso: %s \\n\", argv[0]);",
		  "        exit(1);",
		  "    }",
		  "",
		  "    /* -------- Variabili locali ---------- */",
		  "    int pid[100000];                \t/* process identifier per le fork() */",
		  "    int N;                  \t\t\t/* numero di file passati sulla riga di comando (uguale al numero di file) */",
		  "    pipe_t *piped;          \t\t\t/* array dinamico di pipe descriptors per comunicazioni figli-padre  */",
		  "    int i, j;               \t\t\t/* indici per i cicli */",
		  "    int pidWaitedSon, status, ritorno;\t/* per valore di ritorno dei vari processi (figli/nipoti) */",
		  "    int nr,nw;\t\t\t\t\t\t\t/* variabili per salvare valori di ritorno di read e write da/su pipe */",
		  "    int fd;              \t\t\t\t/* file descriptor */",
		  "    /* other variables */",
		  "    /* ------------------------------------ */",
		  "",
		  "    /* Salvo il numero dei file in una variabile */",
		  "    N = argc - 1; ",
		  "",
		  "    /* Alloco memoria per l'array delle pipe per la comunicazione figlio-padre */",
		  "    if(!(piped = (pipe_t*) malloc(N * sizeof(pipe_t)))) {",
		  "        printf(\"Errore: Impossibile allocare memoria per l'array delle pipe per la comunicazione figlio-padre!\\n\");",
		  "        exit(2);",
		  "    }",
		  "",
		  "    /* Inizializzo l'array delle pipe */",
		  "    for(i = 0; i < N; i++) {",
		  "        if(pipe(piped[i]) < 0) {",
		  "            printf(\"Errore: Impossibile inizializzare l'array delle pipe, si è bloccato alla pipe di indice: %d!\\n\", i);",
		  "            exit(3);",
		  "        }",
		  "    }",
		  "",
		  "    printf(\"--------------------------\\n\");",
		  "    printf(\"DEBUG: Sono il padre con pid=%d e sto per creare [%d] figli!\\n\", getpid(), N);",
		  "    printf(\"--------------------------\\n\");",
		  "",
		  "    /* Creo N processi figli */",
		  "    for(i = 0; i < N; i++) {",
		  "",
		  "        if((pid[i] = fork()) < 0) {",
		  "            printf(\"Errore: Impossibile creare il processo figlio %d-esimo!\\n\", i);",
		  "            exit(4);",
		  "        }",
		  "",
		  "        /* Codice del processo figlio */",
		  "        if(pid[i] == 0) {",
		  "",
		  "            /* Chiudo tutte le pipe di non interesse */",
		  "            for(j = 0; j < N; j++) {",
		  "                if (j != i)",
		  "                    close(piped[j][1]);",
		  "                if ((i == 0) || (j != i-1))",
		  "                    close(piped[j][0]);",
		  "            }",
		  "",
		  "            /*###############son operation###################*/",
		  "            if (i != 0) {",
		  "",
		  "                /* leggiamo dalla pipe il valore corrente */",
		  "                nr = read(piped[i-1][0], /* data */NULL, sizeof(int));",
		  "",
		  "                if (nr != sizeof(int)) {",
		  "                    printf(\"Errore in lettura dalla pipe %d-esima\\n\", i-1);",
		  "                    exit(-1);",
		  "                }",
		  "            }",
		  "",
		  "            /* scriviamo sulla pipe il valore aggiornato */",
		  "            nw = write(piped[i][1], /* data */NULL, sizeof(int));",
		  "            if (nw != sizeof(int)) {",
		  "                printf(\"Errore in scrittura sulla pipe %d-esima\\n\", i);",
		  "                exit(-1);",
		  "            }",
		  "",
		  "            exit(0); /* return del figlio al padre */",
		  "        }",
		  "    }",
		  "",
		  "    /* Codice del processo padre */",
		  "",
		  "    /* Chiudo tutte le pipe di non interesse */",
		  "    for(i = 0; i < N; i++) {",
		  "        close(piped[i][1]);",
		  "        if (i != N-1)",
		  "            close(piped[i][0]);",
		  "    }",
		  "    ",
		  "    /*###############father operation###################*/",
		  "    /* il padre deve leggere un solo array, chiaramente controllando l'esito della lettura! */",
		  "    nr = read(piped[N-1][0], /* data */NULL, sizeof(int));",
		  "    if (nr != sizeof(int)) {",
		  "        printf(\"Errore in lettura dalla pipe %d-esima\\n\", N-1);",
		  "        exit(4);",
		  "    } else {",
		  "        /* some operation */",
		  "        for(i = 0; i < N; i++) {",
		  "            /* some operation */",
		  "        }",
		  "    }",
		  "",
		  "",
		  "    /* Il padre aspetta i figli salvando lo status */",
		  "    for (int i = 0; i < N; i++) {",
		  "        if ((pidWaitedSon = wait(&status)) < 0) {",
		  "            printf(\"Errore in wait per il figlio %d-esimo!\\n\", i);",
		  "            exit(5);",
		  "        }",
		  "        if ((status & 0xFF) != 0)",
		  "            printf(\"Figlio %d-esimo con pid %d terminato in modo anomalo\\n\", i, pidWaitedSon);",
		  "        else {",
		  "            ritorno = (int)((status >> 8) & 0xFF);",
		  "            printf(\"--------------------------\\n\");",
		  "            printf(\"DEBUG: Il figlio %d-esimo con pid=%d ha ritornato %d (se 255 problemi)\\n\", i, pidWaitedSon, ritorno);",
		  "            printf(\"--------------------------\\n\");",
		  "        }",
		  "    }",
		  "",
		  "    exit(0); /* return del padre al sistema */",
		  "}"
		],
		"description": "Figli con comunicazione tra figli, ultimo figlio con il padre"
	  },
	"mia_random": {
		"prefix": "random",
		"body": [
			"#include <time.h>",
		  	"//DA AGGIUNGERE NEL MAIN",
		  	"//srand(time(NULL));",
		  	"//PER OTTENERE RANDOM",
		  	"//int r = mia_random(100);",
			"",
			"int mia_random(int n) {",
			"\tint casuale;",
			"\tcasuale = rand() % n;",
			"\treturn casuale;",
			"}"
		],
		"description": "Generate a random number between 0 and n-1"
	},
	"convertiUltimaStringaInNumero": {
		"prefix": "convertiUltimaStringaInNumero",
		"body": [
			"H = atoi(argv[argc-1]);",
			"if ((H <= 0) || (H >= 255)) {",
			"\tprintf(\"Errore nel numero passato %d\\n\", H);",
			"\texit(000000);",
			"}"
		],
		"description": "Convert the last string argument to a number and perform error checking"
	},
	"creazione file in /tmp": {
		"prefix": "creaFileTmp",
		"body": [
			"/* creazione file in /tmp */",
			"/* usato la open in versione estesa per azzerare il file nel caso esista gia' */",
			"if ((fdout=open(\"/tmp/creato\", O_CREAT|O_WRONLY|O_TRUNC, 0644)) < 0) {",
			"\tprintf(\"Errore nella creazione del file %s\\n\", \"/tmp/creato\");",
			"\texit(00000);",
			"}"
		],
		"description": "Creazione file in /tmp"
	},
	"Pipeline figlio padre e padre figlio": {
		"prefix": "figlioPadreEFiglioPadre",
		"body": [
		  "/* File 12Set18.c */",
		  "/* Standard C = C11 */",
		  "",
		  "#include <stdio.h> /* Standard I/O: printf, BUFSIZ */",
		  "#include <fcntl.h> /* File CoNTrol: open, O_RDONLY, O_WRONLY, O_RDWR */",
		  "#include <stdlib.h> /* STanDard LIBrary: exit, malloc, calloc, free, atoi */",
		  "#include <unistd.h> /* UNIx Standard: read, write, close, SEEK_SET, SEEK_CUR, SEEK_END */",
		  "#include <sys/wait.h> /* SYStem WAIT: wait */",
		  "",
		  "typedef int pipe_t[2]; /* Definizione di un tipo pipe_t come array di 2 interi */",
		  "",
		  "",
		  "int main(int argc, char const **argv) {",
		  "    /* controllo numero parametri */",
		  "    if (argc != 3) {",
		  "        printf(\"Error: numero parametri '%d' errato\\n\", argc - 1);",
		  "        printf(\"Uso: %s \\n\", argv[0]);",
		  "        exit(1);",
		  "    }",
		  "",
		  "    /* -------- Variabili locali ---------- */",
		  "    int pid;                /* process identifier per le fork() */",
		  "    int N;                  /* numero di file passati sulla riga di comando (uguale al numero di file) */",
		  "    pipe_t *pipedFP;/* array dinamico di pipe descriptors per comunicazioni figli-padre */",
		  "    pipe_t *pipedPF;/* array dinamico di pipe descriptors per comunicazioni padre-figli */",
		  "    int i, j;               /* indici per i cicli */",
		  "    int pidWaitedSon, status, ritorno;/* per valore di ritorno dei vari processi (figli/nipoti) */",
		  "    int fd;              /* file descriptor */",
		  "    char linea[255];/* array di caratteri per memorizzare la linea, supponendo una lunghezza massima di ogni linea di 255 caratteri compreso il terminatore di linea */",
		  "    int valore; /* variabile che viene usata dal padre per recuperare il valore comunicato da ogni figlio e che contiene la lunghezza della linea corrente */",
		  "    int giusto; /* variabile che viene usata dal padre per salvare per ogni linea il valore inviato dal figlio selezionato in modo random */",
		  "    int r; /* variabile usata dal padre per calcolare i valori random e dal figlio per ricevere il numero dal padre */",
		  "    /* ------------------------------------ */",
		  "",
		  "    /* Salvo il numero dei file in una variabile */",
		  "    N = argc - 1; ",
		  "",
		  "    /* Alloco memoria per l'array delle pipe per la comunicazione figlio-padre */",
		  "    if(!(pipedFP = (pipe_t*) malloc(N * sizeof(pipe_t)))) {",
		  "        printf(\"Errore: Impossibile allocare memoria per l'array delle pipe per la comunicazione figlio-padre!\\n\");",
		  "        exit(2);",
		  "    }",
		  "",
		  "    /* Alloco memoria per l'array delle pipe per la comunicazione padre-figlio */",
		  "    if(!(pipedPF = (pipe_t*) malloc(N * sizeof(pipe_t)))) {",
		  "        printf(\"Errore: Impossibile allocare memoria per l'array delle pipe per la comunicazione padre-figlio!\\n\");",
		  "        exit(3);",
		  "    }",
		  "",
		  "    /* Creazione delle N pipe figli-padre e delle N pipe padre-figli */",
		  "    for(i = 0; i < N; i++) {",
		  "        if(pipe(pipedFP[i]) < 0) {",
		  "            printf(\"Errore: Impossibile creare la pipe figlio-padre %d-esima!\\n\", i);",
		  "            exit(4);",
		  "        }",
		  "        if(pipe(pipedPF[i]) < 0) {",
		  "            printf(\"Errore: Impossibile creare la pipe padre-figlio %d-esima!\\n\", i);",
		  "            exit(5);",
		  "        }",
		  "    }",
		  "",
		  "    printf(\"--------------------------\\n\");",
		  "    printf(\"DEBUG: Sono il padre con pid=%d e sto per creare [%d] figli!\\n\", getpid(), N);",
		  "    printf(\"--------------------------\\n\");",
		  "",
		  "    /* Creo N processi figli */",
		  "    for(i = 0; i < N; i++) {",
		  "",
		  "        if((pid = fork()) < 0) {",
		  "            printf(\"Errore: Impossibile creare il processo figlio %d-esimo!\\n\", i);",
		  "            exit(6);",
		  "        }",
		  "",
		  "        /* Codice del processo figlio */",
		  "        if(pid == 0) {",
		  "",
		  "            /* Chiusura delle pipe non usate nella comunicazione con il padre */",
		  "            for (j = 0; j < N; j++) {",
		  "                close(pipedFP[j][0]);",
		  "                close(pipedPF[j][1]);",
		  "                if (i != j) {",
		  "                    close(pipedFP[j][1]);",
		  "                    close(pipedPF[j][0]);",
		  "                }",
		  "            }",
		  "",
		  "            /*###############son operation###################*/",
		  "",
		  "            /* Apro il file in sola lettura */",
		  "            if((fd = open(argv[i + 1], O_RDONLY)) < 0) {",
		  "                printf(\"Errore: Impossibile aprire il file %s in sola lettura!\\n\", argv[i + 1]);",
		  "                exit(-1);",
		  "            }",
		  "",
		  "            /* adesso il figlio legge dal file una linea alla volta */",
		  "            j=0;",
		  "            while(read(fd, &(linea[j]), 1)){",
		  "                if(linea[j] == '\\n'){",
		  "                    /* dobbiamo mandare al padre la lunghezza della linea corrente compreso il terminatore di linea (come int) e quindi incrementiamo j */",
		  "                    j++;write(pipedFP[i][1], &j, sizeof(j));",
		  "                    /* il figlio Pi deve leggere il valore inviato dal padre */",
		  "                    read(pipedPF[i][0], &r, sizeof(r));",
		  "",
		  "                    if (r < j) {",
		  "                        /* other operation */",
		  "                        // .............",
		  "                    } else {",
		  "                        j = 0; /* azzeriamo l'indice per le prossime linee */",
		  "                    }",
		  "                } else {",
		  "                    j++;",
		  "                }",
		  "            }",
		  "",
		  "            exit(0); /* return del figlio al padre */",
		  "        }",
		  "    }",
		  "",
		  "    /* Codice del processo padre */",
		  "",
		  "    /* Il padre chiude i lati delle pipe che non usa */",
		  "    for (i = 0; i < N; i++) {",
		  "        close(pipedFP[i][1]);",
		  "        close(pipedPF[i][0]);",
		  "    }",
		  "",
		  "    /*###############father operation###################*/",
		  "",
		  "        /* example ---------------------------------------> */",
		  "    /* Il padre recupera le informazioni dai figli: prima in ordine di linee e quindi in ordine di indice */",
		  "    for (j = 1; j <= NUM; j++) {",
		  "        for (i = 0; i < N; i++) {",
		  "            /* il padre recupera tutti i valori interi dai figli */",
		  "            read(pipedFP[i][0], &valore, sizeof(valore));",
		  "            /* ma si salva solo il valore del figlio identificato in modo random */",
		  "            if (i == r)",
		  "                giusto = valore;",
		  "        }",
		  "        r = mia_random(giusto);",
		  "        /* il padre deve inviare a tutti i figli l'indice */",
		  "        for (i = 0; i < N; i++)",
		  "            write(pipedPF[i][1], &r, sizeof(r));",
		  "    }",
		  "    ",
		  "",
		  "",
		  "",
		  "    /* Il padre aspetta i figli salvando lo status */",
		  "    for (int i = 0; i < N; i++) {",
		  "        if ((pidWaitedSon = wait(&status)) < 0) {",
		  "            printf(\"Errore in wait per il figlio %d-esimo!\\n\", i);",
		  "            exit(5);",
		  "        }",
		  "        if ((status & 0xFF) != 0)",
		  "            printf(\"Figlio %d-esimo con pid %d terminato in modo anomalo\\n\", i, pidWaitedSon);",
		  "        else {",
		  "            ritorno = (int)((status >> 8) & 0xFF);",
		  "            printf(\"--------------------------\\n\");",
		  "            printf(\"DEBUG: Il figlio %d-esimo con pid=%d ha ritornato %d (se 255 problemi)\\n\", i, pidWaitedSon, ritorno);",
		  "            printf(\"--------------------------\\n\");",
		  "        }",
		  "    }",
		  "",
		  "    exit(0); /* return del padre al sistema */",
		  "}"
		],
		"description": "Pipeline figlio padre e padre figlio"
	},
	"Pipeline Ring figlio padre": {
		"prefix": "ringFiglioPadre",
		"body": [
		  "/* File 12Set18.c */",
		  "/* Standard C = C11 */",
		  "",
		  "#include <stdio.h> /* Standard I/O: printf, BUFSIZ */",
		  "#include <fcntl.h> /* File CoNTrol: open, O_RDONLY, O_WRONLY, O_RDWR */",
		  "#include <stdlib.h> /* STanDard LIBrary: exit, malloc, calloc, free, atoi */",
		  "#include <unistd.h> /* UNIx Standard: read, write, close, SEEK_SET, SEEK_CUR, SEEK_END */",
		  "#include <sys/wait.h> /* SYStem WAIT: wait */",
		  "",
		  "typedef int pipe_t[2]; /* Definizione di un tipo pipe_t come array di 2 interi */",
		  "",
		  "",
		  "int main(int argc, char const **argv) {",
		  "    /* controllo numero parametri */",
		  "    if (argc != 3) {",
		  "        printf(\"Error: numero parametri '%d' errato\\n\", argc - 1);",
		  "        printf(\"Uso: %s \\n\", argv[0]);",
		  "        exit(1);",
		  "    }",
		  "",
		  "    /* -------- Variabili locali ---------- */",
		  "    int pid;                /* process identifier per le fork() */",
		  "    int N;                  /* numero di file passati sulla riga di comando (uguale al numero di file) */",
		  "    pipe_t *piped;          /* array dinamico di pipe descriptors per comunicazioni figli-padre  */",
		  "    int i, j;               /* indici per i cicli */",
		  "    int pidWaitedSon, status, ritorno;/* per valore di ritorno dei vari processi (figli/nipoti) */",
		  "    int fd;              /* file descriptor */",
		  "    int nr,nw;              /* variabili per salvare valori di ritorno di read/write da/su pipe */",
		  "    char ok;/* carattere letto dai figli dalla pipe precedente e scritta su quella successiva */",
		  "    char ch;       /* carattere lette dai figli dall'unico file */",
		  "    int nrChar;/* contatore carattere cercato per ogni linea */",
		  "    int L;/* per valore numero linee del file */",
		  "    ",
		  "    /* ------------------------------------ */",
		  "",
		  "    /* Salvo il numero dei file in una variabile */",
		  "    N = argc - 1; ",
		  "",
		  "    /* Alloco memoria per l'array delle pipe per la comunicazione figlio-padre */",
		  "    if(!(piped = (pipe_t*) malloc((N + 1) * sizeof(pipe_t)))) {",
		  "        printf(\"Errore: Impossibile allocare memoria per l'array delle pipe per la comunicazione figlio-padre!\\n\");",
		  "        exit(2);",
		  "    }",
		  "",
		  "    /* Inizializzo l'array delle pipe */",
		  "    for(i = 0; i < N + 1; i++) {",
		  "        if(pipe(piped[i]) < 0) {",
		  "            printf(\"Errore: Impossibile inizializzare l'array delle pipe, si è bloccato alla pipe di indice: %d!\\n\", i);",
		  "            exit(3);",
		  "        }",
		  "    }",
		  "",
		  "    printf(\"--------------------------\\n\");",
		  "    printf(\"DEBUG: Sono il padre con pid=%d e sto per creare [%d] figli!\\n\", getpid(), N);",
		  "    printf(\"--------------------------\\n\");",
		  "",
		  "    /* Creo N processi figli */",
		  "    for(i = 0; i < N; i++) {",
		  "",
		  "        if((pid = fork()) < 0) {",
		  "            printf(\"Errore: Impossibile creare il processo figlio %d-esimo!\\n\", i);",
		  "            exit(4);",
		  "        }",
		  "",
		  "        /* Codice del processo figlio */",
		  "        if(pid == 0) {",
		  "",
		  "            /* Chiudo tutte le pipe di non interesse */",
		  "            for(j = 0; j < N + 1; j++) {",
		  "                if(i != j)",
		  "                    close(piped[j][0]);",
		  "                if(j != (i + 1))",
		  "                    close(piped[j][1]);",
		  "            }",
		  "",
		  "            /*###############son operation###################*/",
		  "                /* EXAMPLES OF SON OPERATION --------------------*/",
		  "",
		  "            /* apertura file */",
		  "            if ((fd = open(argv[1], O_RDONLY)) < 0) {",
		  "                printf(\"Impossibile aprire il file %s\\n\", argv[1]);",
		  "                exit(-1);",
		  "            }",
		  "",
		  "            /* inizializziamo il contatore del carattere cercato per ogni singola linea */",
		  "            nrChar = 0;",
		  "            /* con un ciclo leggiamo tutte le linee, come richiede la specifica */",
		  "            while (read(fd, &ch, 1) != 0) {",
		  "                if (ch == '\\n') { /* siamo a fine linea */",
		  "                    /* dobbiamo aspettare l'ok dal figlio precedente per scrivere */",
		  "                    nr = read(piped[q][0], &ok, sizeof(char));",
		  "                    /* per sicurezza controlliamo il risultato della lettura da pipe */",
		  "                    if (nr != sizeof(char)) {",
		  "                        printf(\"Figlio %d ha letto un numero di byte sbagliati %d\\n\", q, nr);",
		  "                        exit(-1);",
		  "                    }",
		  "                    /* a questo punto si deve riportare su standard output l'indice e il pid del processo, il numero di caratteri cercato presenti e la linea letta */",
		  "                    printf(\"Figlio con indice %d e pid %d ha letto %d caratteri %c nella linea corrente\\n\", q, getpid(), nrChar, argv[q + 3][0]);",
		  "                    /* ora si deve mandare l'OK in avanti: nota che il valore della variabile ok non ha importanza */",
		  "                    nw = write(piped[q + 1][1], &ok, sizeof(char));",
		  "                    /* anche in questo caso controlliamo il risultato della scrittura */",
		  "                    if (nw != sizeof(char)) {",
		  "                        printf(\"Figlio %d ha scritto un numero di byte sbagliati %d\\n\", q, nw);",
		  "                        exit(-1);",
		  "                    }",
		  "                    /* si deve azzerare il conteggio delle occorrenze, dopo averlo salvato per poterlo tornare correttamente, nel caso la linea corrente sia l'ultima! */",
		  "                    ritorno = nrChar;",
		  "                    nrChar = 0;",
		  "                } else {",
		  "                    /* se non siamo a fine linea dobbiamo fare il controllo sul carattere corrente */",
		  "                    if (ch == argv[q + 3][0]) { /* se abbiamo letto il carattere da cercare incrementiamo il contatore */",
		  "                        nrChar++;",
		  "                    }",
		  "                }",
		  "            }",
		  "            /* ogni figlio deve tornare il numero di caratteri numerici dell'ultima linea */",
		  "            exit(ritorno); /* return del figlio al padre */",
		  "        }",
		  "    }",
		  "",
		  "    /* Codice del processo padre */",
		  "",
		  "    /* chiusura di tutte le pipe che non usa, a parte la prima e l'ultima */",
		  "    for (int i = 0; i < N + 1; i++) {",
		  "        if (i != N) close(piped[i][0]);",
		  "        if (i != 0) close(piped[i][1]);",
		  "    }",
		  "",
		  "    /* Poiche' in questo caso il padre e' nel ring, non ci sono problemi di dover lasciare aperti lati di pipe che il padre non usa! */",
		  "",
		  "    ",
		  "    /*###############father operation###################*/",
		  "",
		  "        /* EXAMPLES OF FATHER OPERATION --------------------*/",
		  "    for (j = 0; j < L; j++) { /* il padre deve leggere una riga per volta da ciascun file */",
		  "        /* il padre deve riportare il numero di linea correntemente analizzata dai figli, insieme con il nome del file */",
		  "        printf(\"Linea %d del file %s\\n\", j + 1, argv[1]); /* il numero di linea deve partire da 1! */",
		  "        /* il padre deve inviare un 'segnale' di sincronizzazione al processo di indice 0 */",
		  "        nw = write(piped[0][1], &ok, sizeof(char));",
		  "        /* anche in questo caso controlliamo il risultato della scrittura */",
		  "        if (nw != sizeof(char)) {",
		  "            printf(\"Padre ha scritto un numero di byte sbagliati %d\\n\", nw);",
		  "            exit(7);",
		  "        }",
		  "        /* il padre quindi deve aspettare che l'ultimo figlio gli invii il 'segnale' di sincronizzazione per fare ripartire il ring */",
		  "        nr = read(piped[Q][0], &ok, sizeof(char));",
		  "        /* per sicurezza controlliamo il risultato della lettura da pipe */",
		  "        if (nr != sizeof(char)) {",
		  "            printf(\"Padre ha letto un numero di byte sbagliati %d\\n\", nr);",
		  "            exit(8);",
		  "        }",
		  "    }",
		  "",
		  "    /* Il padre aspetta i figli salvando lo status */",
		  "    for (int i = 0; i < N; i++) {",
		  "        if ((pidWaitedSon = wait(&status)) < 0) {",
		  "            printf(\"Errore in wait per il figlio %d-esimo!\\n\", i);",
		  "            exit(5);",
		  "        }",
		  "        if ((status & 0xFF) != 0)",
		  "            printf(\"Figlio %d-esimo con pid %d terminato in modo anomalo\\n\", i, pidWaitedSon);",
		  "        else {",
		  "            ritorno = (int)((status >> 8) & 0xFF);",
		  "            printf(\"--------------------------\\n\");",
		  "            printf(\"DEBUG: Il figlio %d-esimo con pid=%d ha ritornato %d (se 255 problemi)\\n\", i, pidWaitedSon, ritorno);",
		  "            printf(\"--------------------------\\n\");",
		  "        }",
		  "    }",
		  "",
		  "    exit(0); /* return del padre al sistema */",
		  "}"
		],
		"description": "Pipeline Ring figlio padre"
	  }
	

			
	
}