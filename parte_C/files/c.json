{
	"main": {
		"prefix": "main",
		"body": [
			"",
			"int main(int argc, char **argv) {",
			"    $1",
			"    exit(0);",
			"}"
		],
		"description": "Main function"
	},
	"librerie": {
		"prefix": "lib",
		"body": [
			"/* File ${TM_FILENAME} */",
			"/* Standard C = C11 */",
			"",
			"#include <stdio.h> /* Standard I/O: printf, BUFSIZ */",
			"#include <fcntl.h> /* File CoNTrol: open, O_RDONLY, O_WRONLY, O_RDWR */",
			"#include <stdlib.h> /* STanDard LIBrary: exit, malloc, calloc, free, atoi */",
			"#include <unistd.h> /* UNIx Standard: read, write, close, SEEK_SET, SEEK_CUR, SEEK_END */",
			"#include <string.h> /* STRING: strlen, strcpy, strcmp */",
			"#include <sys/stat.h> /* SYStem STATus: stat, fstat, S_IFMT, S_IFDIR, S_IFREG */",
			"#include <sys/wait.h> /* SYStem WAIT: wait */",
			"#include <sys/types.h> /* SYStem TYPES: pid_t */",
			"",
			"typedef int pipe_t[2]; /* Definizione di un tipo pipe_t come array di 2 interi */"
		],
		"description": "Libraries"
	},
	"printf": {
		"prefix": "printf",
		"body": [
			"printf(\"$1\\n\");"
		],
		"description": "Print to console"
	},
	"for": {
		"prefix": "for",
		"body": [
			"for (int ${1:i} = 0; ${1:i} < $2; ${1:i}++) {",
			"    $3",
			"}"
		],
		"description": "For loop"
	},
	"if": {
		"prefix": "if",
		"body": [
			"if ($1) {",
			"    $2",
			"}"
		],
		"description": "If statement"
	},
	"else": {
		"prefix": "else",
		"body": [
			"else {",
			"    $1",
			"}"
		],
		"description": "Else statement"
	},
	"else if": {
		"prefix": "elif",
		"body": [
			"else if ($1) {",
			"    $2",
			"}"
		],
		"description": "Else if statement"
	},
	"while": {
		"prefix": "while",
		"body": [
			"while ($1) {",
			"    $2",
			"}"
		],
		"description": "While loop"
	},
	"Struct": {
		"prefix": "structEsempio",
		"body": [
			"typedef struct{",
			"    int c1;",
			"    int c2;",
			"    char c3[250];",
			"} msg;"
		],
		"description": "Struct"
	},
	"switch": {
		"prefix": "switch",
		"body": [
			"switch ($1) {",
			"    case $2:",
			"        $3",
			"        break;",
			"    default:",
			"        $4",
			"        break;",
			"}"
		],
		"description": "Switch statement"
	},
	"Controllo che sia singolo carattere": {
		"prefix": "singolo",
		"body": [
			"/* controllo che il ${2:XXXX} parametro sia un singolo carattere */",
			"if (argv[$1][1] != '\\0') {",
			"\tprintf(\"Error: %s non singolo carattere\\n\", argv[$1]);",
			"\texit(${3:0000});",
			"}",
			"char ${4:C} = argv[$1][0];"
		],
		"description": "Controllo che sia singolo carattere"
	},
	"Leggi tutto un file carattere per carattere": {
		"prefix": "leggiFileCaratterePerCarattere",
		"body": [
			"/* leggi tutto il file */",
			"char c;",
			"while (read(${1:file}, &c, 1)) {",
			"    printf(\"%c\", c);",
			"}"
		],
		"description": "Leggi tutto un file carattere per carattere"
	},
	"Leggi e trasforma file": {
		"prefix": "leggiTrasformaFile",
		"body": [
			"/* Leggo il file carattere per carattere */",
			"while (read(fd, &ch, 1)) {",
			"    /* controlliamo se abbiamo trovato un carattere alfabetico minuscolo */",
			"    if (islower(ch)) {",
			"        /* trasformiamo il carattere in maiuscolo */",
			"        ch = toupper(ch);",
			"        /* ci posizioniamo all'inizio del carattere da sovrascrivere */",
			"        lseek(fd, -1L, SEEK_CUR);",
			"        /* sovrascriviamo il carattere */",
			"        write(fd, &ch, 1);",
			"        /* incrementiamo il contatore delle trasformazioni */",
			"        trasformazioni++;",
			"    }",
			"}"
		],
		"description": "Leggi e trasforma file"
	},
	"Apri file in lettura": {
		"prefix": "apriFileLettura",
		"body": [
			"/* Apertura file in lettura */",
			"if ((fd = open(argv[$1], O_RDONLY)) < 0) {",
			"    printf(\"Errore in apertura file '%s' in lettura\\n\", argv[$1]);",
			"    exit(${2:0000});",
			"}"
		],
		"description": "Apri file in lettura"
	},
	"Apri file in scrittura o crealo o troncalo": {
		"prefix": "apriFileScritturaOCreatOTrunc",
		"body": [
			"/* Apertura file in scrittura */",
			"if ((fdw = open(argv[$1], O_WRONLY | O_CREAT | O_TRUNC, 0644)) < 0) {",
			"    printf(\"Errore in apertura file '%s' in scrittura\\n\", argv[$1]);",
			"    exit(${2:0000});",
			"}"
		],
		"description": "Apri file in scrittura o crealo o troncalo"
	},
	"Apri file in scrittura": {
		"prefix": "apriFileScrittura",
		"body": [
			"/* Apertura file in scrittura */",
			"if ((fdw = open(argv[$1], O_WRONLY)) < 0) {",
			"    printf(\"Errore in apertura file '%s' in scrittura\\n\", argv[$1]);",
			"    exit(${2:0000});",
			"}"
		],
		"description": "Apri file in scrittura"
	},
	"Crea file": {
		"prefix": "creaFile",
		"body": [
			"/* Creazione file */",
			"if ((fd = creat(argv[$1], 0644)) < 0) {",
			"    printf(\"Errore in creazione file '%s'\\n\", argv[$1]);",
			"    exit(${2:0000});",
			"}"
		],
		"description": "Crea file"
	},
	"Leggi il numero di righe di un file": {
		"prefix": "leggiNumeroRighe",
		"body": [
			"/* Leggi il numero di righe di un file */",
			"int righe = 0;",
			"char c;",
			"while (read(fd, &c, 1)) {",
			"    if (c == '\\n')",
			"        righe++;",
			"}"
		],
		"description": "Leggi il numero di righe di un file"
	},
	"Controllo numero parametri": {
		"prefix": "numeroParametri",
		"body": [
			"/* controllo numero parametri */",
			"if (argc != $1) {",
			"    printf(\"Error: numero parametri '%d' errato\\n\", argc - 1);",
			"\tprintf(\"Uso: %s $2\\n\", argv[0]);",
			"    exit(${3:0000});",
			"}"
		],
		"description": "Controllo numero parametri"
	},
	"variabili locali": {
		"prefix": "variabiliLocali",
		"body": [
			"/* -------- Variabili locali ---------- */",
			"int pid;                \t\t/* process identifier per le fork() */",
			"int N;                  \t\t/* numero di file passati sulla riga di comando (uguale al numero di file) */",
			"pipe_t *piped;          \t\t/* array dinamico di pipe descriptors per comunicazioni figli-padre  */",
			"pipe_t p;               \t\t/* una sola pipe per ogni coppia figlio-nipote */",
			"int i, j;               \t\t/* indici per i cicli */",
			"int pidFiglio, status, ritorno;\t/* per valore di ritorno figli */",
			"$1",
			"/* ------------------------------------ */"
		],
		"description": "Variabili locali"
	},
	"Controllo che sia un numero strettamente positivo": {
		"prefix": "numeroPositivo",
		"body": [
			"/* controllo che il ${2:XXXX} parametro sia un numero strettamente positivo */",
			"int num = atoi(argv[$1]);",
			"if (num <= 0) {",
			"    printf(\"Error: %s non e' un numero strettamente positivo\\n\", argv[$1]);",
			"    exit(${3:0000});",
			"}"
		],
		"description": "Controllo che sia un numero strettamente positivo"
	},
	"creazione di N pipe": {
		"prefix": "creaPipe",
		"body": [
			"/* Creazione di N pipe */",
			"if ((piped = (pipe_t *) malloc(N * sizeof(pipe_t))) == NULL) {",
			"    printf(\"Errore allocazione pipe\\n\");",
			"    exit(${1:0000});",
			"}",
			"for (i = 0; i < N; i++) {",
			"    if (pipe(piped[i]) < 0) {",
			"        printf(\"Errore creazione pipe\\n\");",
			"        exit(${2:0000});",
			"    }",
			"}"
		],
		"description": "creazione di N pipe"
	},
	"Commento variabile del testo": {
		"prefix": "variabileTesto",
		"body": [
			"/* ATTENZIONE '$1' variabile del testo */"
		],
		"description": "Commento variabile del testo"
	},
	"conta numero di caratteri uguali a Cx in file": {
		"prefix": "contaCharUgualiACx",
		"body": [
			"//Ritorna il numero di occorrenze del carattere Cx nel file F",
			"long int contaOccorrenzeCarattere(const char *F, char Cx){",
			"    /* Apertura file */",
			"    int fd, n;",
			"    if((fd = open(F, O_RDONLY)) < 0){",
			"        printf(\"Errore: impossibile aprire il file %s\\n\", F);",
			"        exit(${1:EXITCODE});",
			"    }",
			"    char buffer;",
			"    long int occorrenze = 0;",
			"    /* Lettura file carattere per carattere */",
			"    while((n = read(fd, &buffer, 1)) > 0){",
			"        if(buffer == Cx){",
			"            occorrenze++;",
			"        }",
			"    }",
			"    printf(\"Il carattere %c compare %ld volte nel file %s\\n\", Cx, occorrenze, F);",
			"    close(fd);",
			"    return occorrenze;",
			"}"
		],
		"description": "conta numero di caratteri uguali  a Cx in file"
	},
	"Wait padre": {
		"prefix": "waitPadre",
		"body": [
			"/* Il padre aspetta i figli salvando lo status */",
			"for (int i = 0; i < N; i++) {",
			"    if ((pidFiglio = wait(&status)) < 0) {",
			"        printf(\"Errore in wait\\n\");",
			"        exit(5);",
			"    }",
			"    if ((status & 0xFF) != 0)",
			"        printf(\"Figlio con pid %d terminato in modo anomalo\\n\", pidFiglio);",
			"    else {",
			"        ritorno = (int)((status >> 8) & 0xFF);",
			"        printf(\"Il figlio con pid=%d ha ritornato il carattere %c (in decimale %d, se 255 problemi)\\n\", pidFiglio, ritorno, ritorno);",
			"    }",
			"}"
		],
		"description": "Wait padre"
	},
	"debug": {
		"prefix": "debug",
		"body": [
			"printf(\"--------------------------\\n\");",
			"printf(\"DEBUG: $1\\n\");",
			"printf(\"--------------------------\\n\");"
		],
		"description": "Debug"
	},
	"Pipeline figlio che comunica con il padre": {
		"prefix": "figlio->padre",
		"body": [
			"/* File ${TM_FILENAME} */",
			"/* Standard C = C11 */",
			"",
			"#include <stdio.h> /* Standard I/O: printf, BUFSIZ */",
			"#include <fcntl.h> /* File CoNTrol: open, O_RDONLY, O_WRONLY, O_RDWR */",
			"#include <stdlib.h> /* STanDard LIBrary: exit, malloc, calloc, free, atoi */",
			"#include <unistd.h> /* UNIx Standard: read, write, close, SEEK_SET, SEEK_CUR, SEEK_END */",
			"#include <sys/wait.h> /* SYStem WAIT: wait */",
			"",
			"typedef int pipe_t[2]; /* Definizione di un tipo pipe_t come array di 2 interi */",
			"",
			"",
			"int main(int argc, char const **argv) {",
			"    /* controllo numero parametri */",
			"    if (argc != 3) {",
			"        printf(\"Error: numero parametri '%d' errato\\n\", argc - 1);",
			"        printf(\"Uso: %s \\n\", argv[0]);",
			"        exit(1);",
			"    }",
			"",
			"    /* -------- Variabili locali ---------- */",
			"    int pid;                \t\t\t/* process identifier per le fork() */",
			"    int N;                  \t\t\t/* numero di file passati sulla riga di comando (uguale al numero di file) */",
			"    pipe_t *piped;          \t\t\t/* array dinamico di pipe descriptors per comunicazioni figli-padre  */",
			"    int i, j;               \t\t\t/* indici per i cicli */",
			"    int pidWaitedSon, status, ritorno;\t/* per valore di ritorno dei vari processi (figli/nipoti) */",
			"    int fd;              \t\t\t\t/* file descriptor */",
			"    ",
			"    /* ------------------------------------ */",
			"",
			"    /* Salvo il numero dei file in una variabile */",
			"    N = argc - 1; ",
			"",
			"    /* Alloco memoria per l'array delle pipe per la comunicazione figlio-padre */",
			"    if(!(piped = (pipe_t*) malloc(N * sizeof(pipe_t)))) {",
			"        printf(\"Errore: Impossibile allocare memoria per l'array delle pipe per la comunicazione figlio-padre!\\n\");",
			"        exit(2);",
			"    }",
			"",
			"    /* Inizializzo l'array delle pipe */",
			"    for(i = 0; i < N; i++) {",
			"        if(pipe(piped[i]) < 0) {",
			"            printf(\"Errore: Impossibile inizializzare l'array delle pipe, si è bloccato alla pipe di indice: %d!\\n\", i);",
			"            exit(3);",
			"        }",
			"    }",
			"",
			"    printf(\"--------------------------\\n\");",
			"    printf(\"DEBUG: Sono il padre con pid=%d e sto per creare [%d] figli!\\n\", getpid(), N);",
			"    printf(\"--------------------------\\n\");",
			"",
			"    /* Creo N processi figli */",
			"    for(i = 0; i < N; i++) {",
			"",
			"        if((pid = fork()) < 0) {",
			"            printf(\"Errore: Impossibile creare il processo figlio %d-esimo!\\n\", i);",
			"            exit(4);",
			"        }",
			"",
			"        /* Codice del processo figlio */",
			"        if(pid == 0) {",
			"",
			"            /* Chiudo tutte le pipe di non interesse */",
			"            for(j = 0; j < N; j++) {",
			"                close(piped[j][0]);",
			"                if(i != j)",
			"                    close(piped[j][1]);",
			"            }",
			"",
			"            /*###############son operation###################*/",
			"",
			"            exit(0); /* return del figlio al padre */",
			"        }",
			"    }",
			"",
			"    /* Codice del processo padre */",
			"",
			"    /* Chiudo tutte le pipe di non interesse */",
			"    for(i = 0; i < N; i++) {",
			"        close(piped[i][1]);",
			"    }",
			"    ",
			"    /*###############father operation###################*/",
			"",
			"",
			"",
			"    /* Il padre aspetta i figli salvando lo status */",
			"    for (i = 0; i < N; i++) {",
			"        if ((pidWaitedSon = wait(&status)) < 0) {",
			"            printf(\"Errore in wait per il figlio %d-esimo!\\n\", i);",
			"            exit(5);",
			"        }",
			"        if ((status & 0xFF) != 0)",
			"            printf(\"Figlio %d-esimo con pid %d terminato in modo anomalo\\n\", i, pidWaitedSon);",
			"        else {",
			"            ritorno = (int)((status >> 8) & 0xFF);",
			"            printf(\"--------------------------\\n\");",
			"            printf(\"DEBUG: Il figlio %d-esimo con pid=%d ha ritornato %d (se 255 problemi)\\n\", i, pidWaitedSon, ritorno);",
			"            printf(\"--------------------------\\n\");",
			"        }",
			"    }",
			"",
			"    exit(0); /* return del padre al sistema */",
			"}"
		],
		"description": "Pipeline figlio che comunica al padre"
	},
	"Pipeline nipote che comunica con il figlio e il figlio con il padre": {
		"prefix": "nipote->figlio->padre",
		"body": [
			"/* File ${TM_FILENAME} */",
			"/* Standard C = C11 */",
			"",
			"#include <stdio.h> /* Standard I/O: printf, BUFSIZ */",
			"#include <fcntl.h> /* File CoNTrol: open, O_RDONLY, O_WRONLY, O_RDWR */",
			"#include <stdlib.h> /* STanDard LIBrary: exit, malloc, calloc, free, atoi */",
			"#include <unistd.h> /* UNIx Standard: read, write, close, SEEK_SET, SEEK_CUR, SEEK_END */",
			"#include <sys/wait.h> /* SYStem WAIT: wait */",
			"",
			"typedef int pipe_t[2]; /* Definizione di un tipo pipe_t come array di 2 interi */",
			"",
			"",
			"int main(int argc, char const **argv) {",
			"    /* controllo numero parametri */",
			"    if (argc != 3) {",
			"        printf(\"Error: numero parametri '%d' errato\\n\", argc - 1);",
			"        printf(\"Uso: %s \\n\", argv[0]);",
			"        exit(1);",
			"    }",
			"",
			"    /* -------- Variabili locali ---------- */",
			"    int pid;                \t\t\t/* process identifier per le fork() */",
			"    int N;                  \t\t\t/* numero di file passati sulla riga di comando (uguale al numero di file) */",
			"    pipe_t *piped;          \t\t\t/* array dinamico di pipe descriptors per comunicazioni figli-padre  */",
			"    pipe_t p;               \t\t\t/* una sola pipe per ogni coppia figlio-nipote */",
			"    int i, j;               \t\t\t/* indici per i cicli */",
			"    int pidWaitedSon, status, ritorno;\t/* per valore di ritorno dei vari processi (figli/nipoti) */",
			"    int fd;              \t\t\t\t/* file descriptor */",
			"    ",
			"    /* ------------------------------------ */",
			"",
			"",
			"    /* Salvo il numero dei file in una variabile */",
			"    N = argc - 1; ",
			"",
			"    /* Alloco memoria per l'array delle pipe per la comunicazione figlio-padre */",
			"    if(!(piped = (pipe_t*) malloc(N * sizeof(pipe_t)))) {",
			"        printf(\"Errore: Impossibile allocare memoria per l'array delle pipe per la comunicazione figlio-padre!\\n\");",
			"        exit(2);",
			"    }",
			"",
			"    /* Inizializzo l'array delle pipe */",
			"    for(i = 0; i < N; i++) {",
			"        if(pipe(piped[i]) < 0) {",
			"            printf(\"Errore: Impossibile inizializzare l'array delle pipe, si è bloccato alla pipe di indice: %d!\\n\", i);",
			"            exit(3);",
			"        }",
			"    }",
			"",
			"    printf(\"--------------------------\\n\");",
			"    printf(\"DEBUG: Sono il padre con pid=%d e sto per creare [%d] figli!\\n\", getpid(), N);",
			"    printf(\"--------------------------\\n\");",
			"",
			"    /* Creo N processi figli */",
			"    for(i = 0; i < N; i++) {",
			"",
			"        if((pid = fork()) < 0) {",
			"            printf(\"Errore: Impossibile creare il processo figlio %d-esimo!\\n\", i);",
			"            exit(4);",
			"        }",
			"",
			"        /* Codice del processo figlio */",
			"        if(pid == 0) {",
			"",
			"            /* Chiudo tutte le pipe di non interesse */",
			"            for(j = 0; j < N; j++) {",
			"                close(piped[j][0]);",
			"                if(i != j)",
			"                    close(piped[j][1]);",
			"            }",
			"",
			"            /* creo la pipe per la comunicazione con il nipote */",
			"            if(pipe(p) < 0) {",
			"                printf(\"Errore: Impossibile creare la pipe di collegamento nipote-figlio con pid=%d del figlio %d-esimo!\\n\", getpid(), i);",
			"                exit(-1);",
			"            }",
			"",
			"            /* Genero il processo nipote e verifico che non ci siano errori */",
			"            if((pid = fork()) < 0) {",
			"                printf(\"Errore: Impossibile generare il processo nipote associato al processo figlio %d-esimo con pid=%d!\\n\", i, getpid());",
			"                exit(-1);",
			"            }",
			"",
			"            /* Codice del processo nipote */",
			"            if(pid == 0) {",
			"                /* Chiudo le pipe di non interesse del processo nipote */",
			"                close(piped[i][1]);",
			"                close(p[0]);",
			"",
			"                /*#########################nephew operation#########################*/",
			"",
			"                exit(0); /* return del nipote al figlio */",
			"            }",
			"",
			"            /* Chiudo la pipe di non interesse */",
			"            close(p[1]);",
			"",
			"            /*###############son operation###################*/",
			"",
			"",
			"            /* Aspetto la terminazione del processo nipote */",
			"            if ((pidWaitedSon = wait(&status)) < 0) {",
			"                printf(\"Errore in wait per il nipote associato al figlio %d-esimo con pid=%d!\\n\", i, getpid());",
			"                exit(-1);",
			"            }",
			"            if ((status & 0xFF) != 0)",
			"                printf(\"Il nipote con pid %d terminato in modo anomalo\\n\", pidWaitedSon);",
			"            else {",
			"                ritorno = (int)((status >> 8) & 0xFF);",
			"                printf(\"--------------------------\\n\");",
			"                printf(\"DEBUG: Il nipote con pid=%d ha ritornato %d (se 255 problemi)\\n\", pidWaitedSon, ritorno);",
			"                printf(\"--------------------------\\n\");",
			"            }",
			"",
			"            exit(0); /* return del figlio al padre */",
			"        }",
			"    }",
			"",
			"    /* Codice del processo padre */",
			"",
			"    /* Chiudo tutte le pipe di non interesse */",
			"    for(i = 0; i < N; i++) {",
			"        close(piped[i][1]);",
			"    }",
			"    ",
			"    /*###############father operation###################*/",
			"",
			"",
			"",
			"    /* Il padre aspetta i figli salvando lo status */",
			"    for (i = 0; i < N; i++) {",
			"        if ((pidWaitedSon = wait(&status)) < 0) {",
			"            printf(\"Errore in wait per il figlio %d-esimo!\\n\", i);",
			"            exit(5);",
			"        }",
			"        if ((status & 0xFF) != 0)",
			"            printf(\"Figlio %d-esimo con pid %d terminato in modo anomalo\\n\", i, pidWaitedSon);",
			"        else {",
			"            ritorno = (int)((status >> 8) & 0xFF);",
			"            printf(\"--------------------------\\n\");",
			"            printf(\"DEBUG: Il figlio %d-esimo con pid=%d ha ritornato %d (se 255 problemi)\\n\", i, pidWaitedSon, ritorno);",
			"            printf(\"--------------------------\\n\");",
			"        }",
			"    }",
			"",
			"    exit(0); /* return del padre al sistema */",
			"}"
		],
		"description": "Pipeline nipote che comunica con il figlio e il figlio con il padre"
	},
	"Pipeline nipote E figlio comunica con il padre": {
		"prefix": "nipote+figlio->padre",
		"body": [
			"/* File ${TM_FILENAME} */",
			"/* Standard C = C11 */",
			"",
			"#include <stdio.h> /* Standard I/O: printf, BUFSIZ */",
			"#include <fcntl.h> /* File CoNTrol: open, O_RDONLY, O_WRONLY, O_RDWR */",
			"#include <stdlib.h> /* STanDard LIBrary: exit, malloc, calloc, free, atoi */",
			"#include <unistd.h> /* UNIx Standard: read, write, close, SEEK_SET, SEEK_CUR, SEEK_END */",
			"#include <sys/wait.h> /* SYStem WAIT: wait */",
			"",
			"typedef int pipe_t[2]; /* Definizione di un tipo pipe_t come array di 2 interi */",
			"",
			"",
			"int main(int argc, char const **argv) {",
			"    /* controllo numero parametri */",
			"    if (argc != 3) {",
			"        printf(\"Error: numero parametri '%d' errato\\n\", argc - 1);",
			"        printf(\"Uso: %s \\n\", argv[0]);",
			"        exit(1);",
			"    }",
			"",
			"    /* -------- Variabili locali ---------- */",
			"    int pid;                \t\t\t/* process identifier per le fork() */",
			"    int N;                  \t\t\t/* numero di file passati sulla riga di comando (uguale al numero di file) */",
			"    pipe_t *pipedFP;          \t\t\t/* array dinamico di pipe descriptors per comunicazioni figli-padre  */",
			"    pipe_t *pipedNP;          \t\t\t/* array dinamico di pipe descriptors per comunicazioni nipoti-padre  */",
			"    int i, j;               \t\t\t/* indici per i cicli */",
			"    int pidWaitedSon, status, ritorno;\t/* per valore di ritorno dei vari processi (figli/nipoti) */",
			"    int fd;              \t\t\t\t/* file descriptor */",
			"    ",
			"    /* ------------------------------------ */",
			"",
			"",
			"    /* Salvo il numero dei file in una variabile */",
			"    N = argc - 1; ",
			"",
			"    /* Alloco memoria per l'array delle pipe per la comunicazione figlio-padre */",
			"    if(!(pipedFP = (pipe_t*) malloc(N * sizeof(pipe_t)))) {",
			"        printf(\"Errore: Impossibile allocare memoria per l'array delle pipe per la comunicazione figlio-padre!\\n\");",
			"        exit(2);",
			"    }",
			"",
			"    /* Alloco memoria per l'array delle pipe per la comunicazione nipote-padre */",
			"    if(!(pipedNP = (pipe_t*) malloc(N * sizeof(pipe_t)))) {",
			"        printf(\"Errore: Impossibile allocare memoria per l'array delle pipe per la comunicazione nipote-padre!\\n\");",
			"        exit(3);",
			"    }",
			"",
			"    /* Inizializzo l'array delle pipe */",
			"    for(i = 0; i < N; i++) {",
			"        if(pipe(pipedFP[i]) < 0) {",
			"            printf(\"Errore: Impossibile inizializzare l'array delle pipe per il figlio %d-esimo!\\n\", i);",
			"            exit(4);",
			"        }",
			"        if(pipe(pipedNP[i]) < 0) {",
			"            printf(\"Errore: Impossibile inizializzare l'array delle pipe per il nipote %d-esimo!\\n\", i);",
			"            exit(5);",
			"        }",
			"    }",
			"",
			"    printf(\"--------------------------\\n\");",
			"    printf(\"DEBUG: Sono il padre con pid=%d e sto per creare [%d] figli!\\n\", getpid(), N);",
			"    printf(\"--------------------------\\n\");",
			"",
			"    /* Creo N processi figli */",
			"    for(i = 0; i < N; i++) {",
			"",
			"        if((pid = fork()) < 0) {",
			"            printf(\"Errore: Impossibile creare il processo figlio %d-esimo!\\n\", i);",
			"            exit(6);",
			"        }",
			"",
			"        /* Codice del processo figlio */",
			"        if(pid == 0) {",
			"",
			"            /* Chiudo tutte le pipe di non interesse */",
			"            for(j = 0; j < N; j++) {",
			"                close(pipedFP[j][0]);",
			"                if(i != j)",
			"                    close(pipedFP[j][1]);",
			"            }",
			"",
			"            /* Creo il processo nipote */",
			"            if((pid = fork()) < 0) {",
			"                printf(\"Errore: Impossibile creare il processo nipote!\\n\");",
			"                exit(-1);",
			"            }",
			"",
			"            /* Codice del processo nipote */",
			"            if(pid == 0) {",
			"                /* chiusura della pipe rimasta aperta di comunicazione fra figlio-padre che il nipote non usa */",
			"                close(pipedFP[i][1]);",
			"",
			"                /* Chiudo tutte le pipe di non interesse */",
			"                for(j = 0; j < N; j++) {",
			"                    close(pipedNP[j][0]);",
			"                    if(i != j)",
			"                        close(pipedNP[j][1]);",
			"                }",
			"",
			"                /*###############grandson operation###################*/",
			"",
			"                exit(0); /* return del nipote al figlio */",
			"            }",
			"",
			"            /* le pipe usate dal nipote vanno chiuse TUTTE */",
			"            for(j = 0; j < N; j++) {",
			"                close(pipedNP[j][0]);",
			"                close(pipedNP[j][1]);",
			"            }",
			"",
			"            /*###############son operation###################*/",
			"",
			"            /* il figlio aspetta il nipote */",
			"            if ((pidWaitedSon = wait(&status)) < 0) {",
			"                printf(\"Errore in wait per il nipote %d-esimo con pid=%d!\\n\", i, getpid());",
			"            }",
			"            if ((status & 0xFF) != 0)",
			"                printf(\"Nipote con pid %d terminato in modo anomalo\\n\", pidWaitedSon);",
			"            else {",
			"                ritorno = (int)((status >> 8) & 0xFF);",
			"                printf(\"--------------------------\\n\");",
			"                printf(\"DEBUG: Il Nipote %d-esimo con pid=%d ha ritornato %d (se 255 problemi)\\n\", i, pidWaitedSon, ritorno);",
			"                printf(\"--------------------------\\n\");",
			"            }",
			"",
			"            exit(0); /* return del figlio al padre */",
			"        }",
			"    }",
			"",
			"    /* Codice del processo padre */",
			"",
			"    /* Chiudo tutte le pipe di non interesse */",
			"    for(i = 0; i < N; i++) {",
			"        close(pipedFP[i][1]);",
			"        close(pipedNP[i][1]);",
			"    }",
			"    ",
			"    /*###############father operation###################*/",
			"",
			"",
			"",
			"    /* Il padre aspetta i figli salvando lo status */",
			"    for (i = 0; i < N; i++) {",
			"        if ((pidWaitedSon = wait(&status)) < 0) {",
			"            printf(\"Errore in wait per il figlio %d-esimo!\\n\", i);",
			"            exit(7);",
			"        }",
			"        if ((status & 0xFF) != 0)",
			"            printf(\"Figlio %d-esimo con pid %d terminato in modo anomalo\\n\", i, pidWaitedSon);",
			"        else {",
			"            ritorno = (int)((status >> 8) & 0xFF);",
			"            printf(\"--------------------------\\n\");",
			"            printf(\"DEBUG: Il figlio %d-esimo con pid=%d ha ritornato %d (se 255 problemi)\\n\", i, pidWaitedSon, ritorno);",
			"            printf(\"--------------------------\\n\");",
			"        }",
			"    }",
			"",
			"    exit(0); /* return del padre al sistema */",
			"}"
		],
		"description": "Pipeline nipote E figlio comunica con il padre"
	},
	"Figli che comunicano tra figli, ultimo figlio con il padre": {
		"prefix": "figlio->figlioN->padre",
		"body": [
			"/* File ${TM_FILENAME} */",
			"/* Standard C = C11 */",
			"",
			"#include <stdio.h> /* Standard I/O: printf, BUFSIZ */",
			"#include <fcntl.h> /* File CoNTrol: open, O_RDONLY, O_WRONLY, O_RDWR */",
			"#include <stdlib.h> /* STanDard LIBrary: exit, malloc, calloc, free, atoi */",
			"#include <unistd.h> /* UNIx Standard: read, write, close, SEEK_SET, SEEK_CUR, SEEK_END */",
			"#include <sys/wait.h> /* SYStem WAIT: wait */",
			"",
			"typedef int pipe_t[2]; /* Definizione di un tipo pipe_t come array di 2 interi */",
			"",
			"",
			"int main(int argc, char const **argv) {",
			"    /* controllo numero parametri */",
			"    if (argc != 3) {",
			"        printf(\"Error: numero parametri '%d' errato\\n\", argc - 1);",
			"        printf(\"Uso: %s \\n\", argv[0]);",
			"        exit(1);",
			"    }",
			"",
			"    /* -------- Variabili locali ---------- */",
			"    int pid[100000];                \t/* process identifier per le fork() */",
			"    int N;                  \t\t\t/* numero di file passati sulla riga di comando (uguale al numero di file) */",
			"    pipe_t *piped;          \t\t\t/* array dinamico di pipe descriptors per comunicazioni figli-padre  */",
			"    int i, j;               \t\t\t/* indici per i cicli */",
			"    int pidWaitedSon, status, ritorno;\t/* per valore di ritorno dei vari processi (figli/nipoti) */",
			"    int nr,nw;\t\t\t\t\t\t\t/* variabili per salvare valori di ritorno di read e write da/su pipe */",
			"    int fd;              \t\t\t\t/* file descriptor */",
			"    /* other variables */",
			"    /* ------------------------------------ */",
			"",
			"    /* Salvo il numero dei file in una variabile */",
			"    N = argc - 1; ",
			"",
			"    /* Alloco memoria per l'array delle pipe per la comunicazione figlio-padre */",
			"    if(!(piped = (pipe_t*) malloc(N * sizeof(pipe_t)))) {",
			"        printf(\"Errore: Impossibile allocare memoria per l'array delle pipe per la comunicazione figlio-padre!\\n\");",
			"        exit(2);",
			"    }",
			"",
			"    /* Inizializzo l'array delle pipe */",
			"    for(i = 0; i < N; i++) {",
			"        if(pipe(piped[i]) < 0) {",
			"            printf(\"Errore: Impossibile inizializzare l'array delle pipe, si è bloccato alla pipe di indice: %d!\\n\", i);",
			"            exit(3);",
			"        }",
			"    }",
			"",
			"    printf(\"--------------------------\\n\");",
			"    printf(\"DEBUG: Sono il padre con pid=%d e sto per creare [%d] figli!\\n\", getpid(), N);",
			"    printf(\"--------------------------\\n\");",
			"",
			"    /* Creo N processi figli */",
			"    for(i = 0; i < N; i++) {",
			"",
			"        if((pid[i] = fork()) < 0) {",
			"            printf(\"Errore: Impossibile creare il processo figlio %d-esimo!\\n\", i);",
			"            exit(4);",
			"        }",
			"",
			"        /* Codice del processo figlio */",
			"        if(pid[i] == 0) {",
			"",
			"            /* Chiudo tutte le pipe di non interesse */",
			"            for(j = 0; j < N; j++) {",
			"                if (j != i)",
			"                    close(piped[j][1]);",
			"                if ((i == 0) || (j != i-1))",
			"                    close(piped[j][0]);",
			"            }",
			"",
			"            /*###############son operation###################*/",
			"            if (i != 0) {",
			"",
			"                /* leggiamo dalla pipe il valore corrente */",
			"                nr = read(piped[i-1][0], /* data */NULL, sizeof(int));",
			"",
			"                if (nr != sizeof(int)) {",
			"                    printf(\"Errore in lettura dalla pipe %d-esima\\n\", i-1);",
			"                    exit(-1);",
			"                }",
			"            }",
			"",
			"            /* scriviamo sulla pipe il valore aggiornato */",
			"            nw = write(piped[i][1], /* data */NULL, sizeof(int));",
			"            if (nw != sizeof(int)) {",
			"                printf(\"Errore in scrittura sulla pipe %d-esima\\n\", i);",
			"                exit(-1);",
			"            }",
			"",
			"            exit(0); /* return del figlio al padre */",
			"        }",
			"    }",
			"",
			"    /* Codice del processo padre */",
			"",
			"    /* Chiudo tutte le pipe di non interesse */",
			"    for(i = 0; i < N; i++) {",
			"        close(piped[i][1]);",
			"        if (i != N-1)",
			"            close(piped[i][0]);",
			"    }",
			"    ",
			"    /*###############father operation###################*/",
			"    /* il padre deve leggere un solo array, chiaramente controllando l'esito della lettura! */",
			"    nr = read(piped[N-1][0], /* data */NULL, sizeof(int));",
			"    if (nr != sizeof(int)) {",
			"        printf(\"Errore in lettura dalla pipe %d-esima\\n\", N-1);",
			"        exit(4);",
			"    } else {",
			"        /* some operation */",
			"        for(i = 0; i < N; i++) {",
			"            /* some operation */",
			"        }",
			"    }",
			"",
			"",
			"    /* Il padre aspetta i figli salvando lo status */",
			"    for (i = 0; i < N; i++) {",
			"        if ((pidWaitedSon = wait(&status)) < 0) {",
			"            printf(\"Errore in wait per il figlio %d-esimo!\\n\", i);",
			"            exit(5);",
			"        }",
			"        if ((status & 0xFF) != 0)",
			"            printf(\"Figlio %d-esimo con pid %d terminato in modo anomalo\\n\", i, pidWaitedSon);",
			"        else {",
			"            ritorno = (int)((status >> 8) & 0xFF);",
			"            printf(\"--------------------------\\n\");",
			"            printf(\"DEBUG: Il figlio %d-esimo con pid=%d ha ritornato %d (se 255 problemi)\\n\", i, pidWaitedSon, ritorno);",
			"            printf(\"--------------------------\\n\");",
			"        }",
			"    }",
			"",
			"    exit(0); /* return del padre al sistema */",
			"}"
		],
		"description": "Figli con comunicazione tra figli, ultimo figlio con il padre"
	},
	"mia_random": {
		"prefix": "random",
		"body": [
			"#include <time.h>",
			"//DA AGGIUNGERE NEL MAIN",
			"//srand(time(NULL));",
			"//PER OTTENERE RANDOM",
			"//int r = mia_random(100);",
			"",
			"int mia_random(int n) {",
			"\tint casuale;",
			"\tcasuale = rand() % n;",
			"\treturn casuale;",
			"}"
		],
		"description": "Generate a random number between 0 and n-1"
	},
	"convertiUltimaStringaInNumero": {
		"prefix": "convertiUltimaStringaInNumero",
		"body": [
			"H = atoi(argv[argc-1]);",
			"if ((H <= 0) || (H >= 255)) {",
			"\tprintf(\"Errore nel numero passato %d\\n\", H);",
			"\texit(000000);",
			"}"
		],
		"description": "Convert the last string argument to a number and perform error checking"
	},
	"creazione file in /tmp": {
		"prefix": "creaFileTmp",
		"body": [
			"/* creazione file in /tmp */",
			"/* usato la open in versione estesa per azzerare il file nel caso esista gia' */",
			"if ((fdout=open(\"/tmp/creato\", O_CREAT|O_WRONLY|O_TRUNC, 0644)) < 0) {",
			"\tprintf(\"Errore nella creazione del file %s\\n\", \"/tmp/creato\");",
			"\texit(00000);",
			"}"
		],
		"description": "Creazione file in /tmp"
	},
	"Pipeline figlio comunica con il padre e il padre risponde al figlio": {
		"prefix": "figlio->padre->figlio",
		"body": [
			"/* File ${TM_FILENAME} */",
			"/* Standard C = C11 */",
			"",
			"#include <stdio.h> /* Standard I/O: printf, BUFSIZ */",
			"#include <fcntl.h> /* File CoNTrol: open, O_RDONLY, O_WRONLY, O_RDWR */",
			"#include <stdlib.h> /* STanDard LIBrary: exit, malloc, calloc, free, atoi */",
			"#include <unistd.h> /* UNIx Standard: read, write, close, SEEK_SET, SEEK_CUR, SEEK_END */",
			"#include <sys/wait.h> /* SYStem WAIT: wait */",
			"",
			"typedef int pipe_t[2]; /* Definizione di un tipo pipe_t come array di 2 interi */",
			"",
			"",
			"int main(int argc, char const **argv) {",
			"    /* controllo numero parametri */",
			"    if (argc != 3) {",
			"        printf(\"Error: numero parametri '%d' errato\\n\", argc - 1);",
			"        printf(\"Uso: %s \\n\", argv[0]);",
			"        exit(1);",
			"    }",
			"",
			"    /* -------- Variabili locali ---------- */",
			"    int pid;                /* process identifier per le fork() */",
			"    int N;                  /* numero di file passati sulla riga di comando (uguale al numero di file) */",
			"    pipe_t *pipedFP;/* array dinamico di pipe descriptors per comunicazioni figli-padre */",
			"    pipe_t *pipedPF;/* array dinamico di pipe descriptors per comunicazioni padre-figli */",
			"    int i, j;               /* indici per i cicli */",
			"    int pidWaitedSon, status, ritorno;/* per valore di ritorno dei vari processi (figli/nipoti) */",
			"    int fd;              /* file descriptor */",
			"    char linea[255];/* array di caratteri per memorizzare la linea, supponendo una lunghezza massima di ogni linea di 255 caratteri compreso il terminatore di linea */",
			"    int valore; /* variabile che viene usata dal padre per recuperare il valore comunicato da ogni figlio e che contiene la lunghezza della linea corrente */",
			"    int giusto; /* variabile che viene usata dal padre per salvare per ogni linea il valore inviato dal figlio selezionato in modo random */",
			"    int r; /* variabile usata dal padre per calcolare i valori random e dal figlio per ricevere il numero dal padre */",
			"    /* ------------------------------------ */",
			"",
			"    /* Salvo il numero dei file in una variabile */",
			"    N = argc - 1; ",
			"",
			"    /* Alloco memoria per l'array delle pipe per la comunicazione figlio-padre */",
			"    if(!(pipedFP = (pipe_t*) malloc(N * sizeof(pipe_t)))) {",
			"        printf(\"Errore: Impossibile allocare memoria per l'array delle pipe per la comunicazione figlio-padre!\\n\");",
			"        exit(2);",
			"    }",
			"",
			"    /* Alloco memoria per l'array delle pipe per la comunicazione padre-figlio */",
			"    if(!(pipedPF = (pipe_t*) malloc(N * sizeof(pipe_t)))) {",
			"        printf(\"Errore: Impossibile allocare memoria per l'array delle pipe per la comunicazione padre-figlio!\\n\");",
			"        exit(3);",
			"    }",
			"",
			"    /* Creazione delle N pipe figli-padre e delle N pipe padre-figli */",
			"    for(i = 0; i < N; i++) {",
			"        if(pipe(pipedFP[i]) < 0) {",
			"            printf(\"Errore: Impossibile creare la pipe figlio-padre %d-esima!\\n\", i);",
			"            exit(4);",
			"        }",
			"        if(pipe(pipedPF[i]) < 0) {",
			"            printf(\"Errore: Impossibile creare la pipe padre-figlio %d-esima!\\n\", i);",
			"            exit(5);",
			"        }",
			"    }",
			"",
			"    printf(\"--------------------------\\n\");",
			"    printf(\"DEBUG: Sono il padre con pid=%d e sto per creare [%d] figli!\\n\", getpid(), N);",
			"    printf(\"--------------------------\\n\");",
			"",
			"    /* Creo N processi figli */",
			"    for(i = 0; i < N; i++) {",
			"",
			"        if((pid = fork()) < 0) {",
			"            printf(\"Errore: Impossibile creare il processo figlio %d-esimo!\\n\", i);",
			"            exit(6);",
			"        }",
			"",
			"        /* Codice del processo figlio */",
			"        if(pid == 0) {",
			"",
			"            /* Chiusura delle pipe non usate nella comunicazione con il padre */",
			"            for (j = 0; j < N; j++) {",
			"                close(pipedFP[j][0]);",
			"                close(pipedPF[j][1]);",
			"                if (i != j) {",
			"                    close(pipedFP[j][1]);",
			"                    close(pipedPF[j][0]);",
			"                }",
			"            }",
			"",
			"            /*###############son operation###################*/",
			"",
			"            /* Apro il file in sola lettura */",
			"            if((fd = open(argv[i + 1], O_RDONLY)) < 0) {",
			"                printf(\"Errore: Impossibile aprire il file %s in sola lettura!\\n\", argv[i + 1]);",
			"                exit(-1);",
			"            }",
			"",
			"            /* adesso il figlio legge dal file una linea alla volta */",
			"            j=0;",
			"            while(read(fd, &(linea[j]), 1)){",
			"                if(linea[j] == '\\n'){",
			"                    /* dobbiamo mandare al padre la lunghezza della linea corrente compreso il terminatore di linea (come int) e quindi incrementiamo j */",
			"                    j++;write(pipedFP[i][1], &j, sizeof(j));",
			"                    /* il figlio Pi deve leggere il valore inviato dal padre */",
			"                    read(pipedPF[i][0], &r, sizeof(r));",
			"",
			"                    if (r < j) {",
			"                        /* other operation */",
			"                        // .............",
			"                    } else {",
			"                        j = 0; /* azzeriamo l'indice per le prossime linee */",
			"                    }",
			"                } else {",
			"                    j++;",
			"                }",
			"            }",
			"",
			"            exit(0); /* return del figlio al padre */",
			"        }",
			"    }",
			"",
			"    /* Codice del processo padre */",
			"",
			"    /* Il padre chiude i lati delle pipe che non usa */",
			"    for (i = 0; i < N; i++) {",
			"        close(pipedFP[i][1]);",
			"        close(pipedPF[i][0]);",
			"    }",
			"",
			"    /*###############father operation###################*/",
			"",
			"        /* example ---------------------------------------> */",
			"    /* Il padre recupera le informazioni dai figli: prima in ordine di linee e quindi in ordine di indice */",
			"    for (j = 1; j <= NUM; j++) {",
			"        for (i = 0; i < N; i++) {",
			"            /* il padre recupera tutti i valori interi dai figli */",
			"            read(pipedFP[i][0], &valore, sizeof(valore));",
			"            /* ma si salva solo il valore del figlio identificato in modo random */",
			"            if (i == r)",
			"                giusto = valore;",
			"        }",
			"        r = mia_random(giusto);",
			"        /* il padre deve inviare a tutti i figli l'indice */",
			"        for (i = 0; i < N; i++)",
			"            write(pipedPF[i][1], &r, sizeof(r));",
			"    }",
			"    ",
			"",
			"",
			"",
			"    /* Il padre aspetta i figli salvando lo status */",
			"    for (i = 0; i < N; i++) {",
			"        if ((pidWaitedSon = wait(&status)) < 0) {",
			"            printf(\"Errore in wait per il figlio %d-esimo!\\n\", i);",
			"            exit(5);",
			"        }",
			"        if ((status & 0xFF) != 0)",
			"            printf(\"Figlio %d-esimo con pid %d terminato in modo anomalo\\n\", i, pidWaitedSon);",
			"        else {",
			"            ritorno = (int)((status >> 8) & 0xFF);",
			"            printf(\"--------------------------\\n\");",
			"            printf(\"DEBUG: Il figlio %d-esimo con pid=%d ha ritornato %d (se 255 problemi)\\n\", i, pidWaitedSon, ritorno);",
			"            printf(\"--------------------------\\n\");",
			"        }",
			"    }",
			"",
			"    exit(0); /* return del padre al sistema */",
			"}"
		],
		"description": "Pipeline figlio comunica con il padre e il padre risponde al figlio"
	},
	"Pipeline Ring figlio padre": {
		"prefix": "ringFiglioPadre",
		"body": [
			"/* File ${TM_FILENAME} */",
			"/* Standard C = C11 */",
			"",
			"#include <stdio.h> /* Standard I/O: printf, BUFSIZ */",
			"#include <fcntl.h> /* File CoNTrol: open, O_RDONLY, O_WRONLY, O_RDWR */",
			"#include <stdlib.h> /* STanDard LIBrary: exit, malloc, calloc, free, atoi */",
			"#include <unistd.h> /* UNIx Standard: read, write, close, SEEK_SET, SEEK_CUR, SEEK_END */",
			"#include <sys/wait.h> /* SYStem WAIT: wait */",
			"",
			"typedef int pipe_t[2]; /* Definizione di un tipo pipe_t come array di 2 interi */",
			"",
			"",
			"int main(int argc, char const **argv) {",
			"    /* controllo numero parametri */",
			"    if (argc != 3) {",
			"        printf(\"Error: numero parametri '%d' errato\\n\", argc - 1);",
			"        printf(\"Uso: %s \\n\", argv[0]);",
			"        exit(1);",
			"    }",
			"",
			"    /* -------- Variabili locali ---------- */",
			"    int pid;                /* process identifier per le fork() */",
			"    int N;                  /* numero di file passati sulla riga di comando (uguale al numero di file) */",
			"    pipe_t *piped;          /* array dinamico di pipe descriptors per comunicazioni figli-padre  */",
			"    int i, j;               /* indici per i cicli */",
			"    int pidWaitedSon, status, ritorno;/* per valore di ritorno dei vari processi (figli/nipoti) */",
			"    int fd;              /* file descriptor */",
			"    int nr,nw;              /* variabili per salvare valori di ritorno di read/write da/su pipe */",
			"    char ok;/* carattere letto dai figli dalla pipe precedente e scritta su quella successiva */",
			"    char ch;       /* carattere lette dai figli dall'unico file */",
			"    int nrChar;/* contatore carattere cercato per ogni linea */",
			"    int L;/* per valore numero linee del file */",
			"    ",
			"    /* ------------------------------------ */",
			"",
			"    /* Salvo il numero dei file in una variabile */",
			"    N = argc - 1; ",
			"",
			"    /* Alloco memoria per l'array delle pipe per la comunicazione figlio-padre */",
			"    if(!(piped = (pipe_t*) malloc((N + 1) * sizeof(pipe_t)))) {",
			"        printf(\"Errore: Impossibile allocare memoria per l'array delle pipe per la comunicazione figlio-padre!\\n\");",
			"        exit(2);",
			"    }",
			"",
			"    /* Inizializzo l'array delle pipe */",
			"    for(i = 0; i < N + 1; i++) {",
			"        if(pipe(piped[i]) < 0) {",
			"            printf(\"Errore: Impossibile inizializzare l'array delle pipe, si è bloccato alla pipe di indice: %d!\\n\", i);",
			"            exit(3);",
			"        }",
			"    }",
			"",
			"    printf(\"--------------------------\\n\");",
			"    printf(\"DEBUG: Sono il padre con pid=%d e sto per creare [%d] figli!\\n\", getpid(), N);",
			"    printf(\"--------------------------\\n\");",
			"",
			"    /* Creo N processi figli */",
			"    for(i = 0; i < N; i++) {",
			"",
			"        if((pid = fork()) < 0) {",
			"            printf(\"Errore: Impossibile creare il processo figlio %d-esimo!\\n\", i);",
			"            exit(4);",
			"        }",
			"",
			"        /* Codice del processo figlio */",
			"        if(pid == 0) {",
			"",
			"            /* Chiudo tutte le pipe di non interesse */",
			"            for(j = 0; j < N + 1; j++) {",
			"                if(i != j)",
			"                    close(piped[j][0]);",
			"                if(j != (i + 1))",
			"                    close(piped[j][1]);",
			"            }",
			"",
			"            /*###############son operation###################*/",
			"                /* EXAMPLES OF SON OPERATION --------------------*/",
			"",
			"            /* apertura file */",
			"            if ((fd = open(argv[1], O_RDONLY)) < 0) {",
			"                printf(\"Impossibile aprire il file %s\\n\", argv[1]);",
			"                exit(-1);",
			"            }",
			"",
			"            /* inizializziamo il contatore del carattere cercato per ogni singola linea */",
			"            nrChar = 0;",
			"            /* con un ciclo leggiamo tutte le linee, come richiede la specifica */",
			"            while (read(fd, &ch, 1) != 0) {",
			"                if (ch == '\\n') { /* siamo a fine linea */",
			"                    /* dobbiamo aspettare l'ok dal figlio precedente per scrivere */",
			"                    nr = read(piped[q][0], &ok, sizeof(char));",
			"                    /* per sicurezza controlliamo il risultato della lettura da pipe */",
			"                    if (nr != sizeof(char)) {",
			"                        printf(\"Figlio %d ha letto un numero di byte sbagliati %d\\n\", q, nr);",
			"                        exit(-1);",
			"                    }",
			"                    /* a questo punto si deve riportare su standard output l'indice e il pid del processo, il numero di caratteri cercato presenti e la linea letta */",
			"                    printf(\"Figlio con indice %d e pid %d ha letto %d caratteri %c nella linea corrente\\n\", q, getpid(), nrChar, argv[q + 3][0]);",
			"                    /* ora si deve mandare l'OK in avanti: nota che il valore della variabile ok non ha importanza */",
			"                    nw = write(piped[q + 1][1], &ok, sizeof(char));",
			"                    /* anche in questo caso controlliamo il risultato della scrittura */",
			"                    if (nw != sizeof(char)) {",
			"                        printf(\"Figlio %d ha scritto un numero di byte sbagliati %d\\n\", q, nw);",
			"                        exit(-1);",
			"                    }",
			"                    /* si deve azzerare il conteggio delle occorrenze, dopo averlo salvato per poterlo tornare correttamente, nel caso la linea corrente sia l'ultima! */",
			"                    ritorno = nrChar;",
			"                    nrChar = 0;",
			"                } else {",
			"                    /* se non siamo a fine linea dobbiamo fare il controllo sul carattere corrente */",
			"                    if (ch == argv[q + 3][0]) { /* se abbiamo letto il carattere da cercare incrementiamo il contatore */",
			"                        nrChar++;",
			"                    }",
			"                }",
			"            }",
			"            /* ogni figlio deve tornare il numero di caratteri numerici dell'ultima linea */",
			"            exit(ritorno); /* return del figlio al padre */",
			"        }",
			"    }",
			"",
			"    /* Codice del processo padre */",
			"",
			"    /* chiusura di tutte le pipe che non usa, a parte la prima e l'ultima */",
			"    for (i = 0; i < N + 1; i++) {",
			"        if (i != N) close(piped[i][0]);",
			"        if (i != 0) close(piped[i][1]);",
			"    }",
			"",
			"    /* Poiche' in questo caso il padre e' nel ring, non ci sono problemi di dover lasciare aperti lati di pipe che il padre non usa! */",
			"",
			"    ",
			"    /*###############father operation###################*/",
			"",
			"        /* EXAMPLES OF FATHER OPERATION --------------------*/",
			"    for (j = 0; j < L; j++) { /* il padre deve leggere una riga per volta da ciascun file */",
			"        /* il padre deve riportare il numero di linea correntemente analizzata dai figli, insieme con il nome del file */",
			"        printf(\"Linea %d del file %s\\n\", j + 1, argv[1]); /* il numero di linea deve partire da 1! */",
			"        /* il padre deve inviare un 'segnale' di sincronizzazione al processo di indice 0 */",
			"        nw = write(piped[0][1], &ok, sizeof(char));",
			"        /* anche in questo caso controlliamo il risultato della scrittura */",
			"        if (nw != sizeof(char)) {",
			"            printf(\"Padre ha scritto un numero di byte sbagliati %d\\n\", nw);",
			"            exit(7);",
			"        }",
			"        /* il padre quindi deve aspettare che l'ultimo figlio gli invii il 'segnale' di sincronizzazione per fare ripartire il ring */",
			"        nr = read(piped[Q][0], &ok, sizeof(char));",
			"        /* per sicurezza controlliamo il risultato della lettura da pipe */",
			"        if (nr != sizeof(char)) {",
			"            printf(\"Padre ha letto un numero di byte sbagliati %d\\n\", nr);",
			"            exit(8);",
			"        }",
			"    }",
			"",
			"    /* Il padre aspetta i figli salvando lo status */",
			"    for (i = 0; i < N; i++) {",
			"        if ((pidWaitedSon = wait(&status)) < 0) {",
			"            printf(\"Errore in wait per il figlio %d-esimo!\\n\", i);",
			"            exit(5);",
			"        }",
			"        if ((status & 0xFF) != 0)",
			"            printf(\"Figlio %d-esimo con pid %d terminato in modo anomalo\\n\", i, pidWaitedSon);",
			"        else {",
			"            ritorno = (int)((status >> 8) & 0xFF);",
			"            printf(\"--------------------------\\n\");",
			"            printf(\"DEBUG: Il figlio %d-esimo con pid=%d ha ritornato %d (se 255 problemi)\\n\", i, pidWaitedSon, ritorno);",
			"            printf(\"--------------------------\\n\");",
			"        }",
			"    }",
			"",
			"    exit(0); /* return del padre al sistema */",
			"}"
		],
		"description": "Pipeline Ring figlio padre"
	},
	"funzione finitof": {
		"prefix": "finitof",
		"body": [
			"/* VARIABILI GLOBALI */",
			"int *finito;  /* array dinamico per indicare i figli che sono terminati */",
			"/* la semantica di questo array e' che ogni elemento vale 0 se il corrispondente processo NON e' finito, altrimenti vale 1 */",
			"int N;        /* numero di processi figli: deve essere una variabile globale perche' deve essere usata dalla funzione finitof */",
			"/* ATTENZIONE 'N' nome indicato nel testo */",
			"int finitof() {",
			"    /* questa funzione verifica i valori memorizzati nell'array finito: ",
			"    appena trova un elemento uguale a 0 vuole dire che non tutti i processi ",
			"    figli sono finiti e quindi torna 0; tornera' 1 se e solo se tutti gli elementi ",
			"    dell'array sono a 1 e quindi tutti i processi sono finiti */",
			"",
			"    for (int i = 0; i < N; i++) {",
			"        if (!finito[i]) {",
			"            /* appena ne trova uno che non ha finito */",
			"            return 0; /* ritorna falso */",
			"        }",
			"    }",
			"    return 1;",
			"}",
			"",
			"// initialize finito nel main",
			"/* allocazione memoria dinamica per finito */",
			"finito = (int *) malloc(sizeof(int) * N);",
			"if(finito == NULL) {",
			"    printf(\"Errore nella allocazione della memoria per array finito\\n\");",
			"    exit(2);",
			"}",
			"/* ... e inizializzazione a 0: all'inizio nessun figlio e' finito */",
			"memset(finito, 0, sizeof(int) * N);"
		],
		"description": "Funzione finitof"
	},
	"Pipeline while !finito": {
		"prefix": "signalConFinitoPipe",
		"body": [
			"/* File ${TM_FILENAME} */",
			"/* Standard C = C11 */",
			"",
			"#include <stdio.h> /* Standard I/O: printf, BUFSIZ */",
			"#include <fcntl.h> /* File CoNTrol: open, O_RDONLY, O_WRONLY, O_RDWR */",
			"#include <stdlib.h> /* STanDard LIBrary: exit, malloc, calloc, free, atoi */",
			"#include <unistd.h> /* UNIx Standard: read, write, close, SEEK_SET, SEEK_CUR, SEEK_END */",
			"#include <string.h> /* STRING: memset */",
			"#include <sys/wait.h> /* SYStem WAIT: wait */",
			"",
			"typedef int pipe_t[2]; /* Definizione di un tipo pipe_t come array di 2 interi */",
			"",
			"/* VARIABILI GLOBALI */",
			"int *finito;  /* array dinamico per indicare i figli che sono terminati */",
			"/* la semantica di questo array e' che ogni elemento vale 0 se il corrispondente processo NON e' finito, altrimenti vale 1 */",
			"int N;        /* numero di processi figli: deve essere una variabile globale perche' deve essere usata dalla funzione finitof */",
			"/* nome indicato nel testo */",
			"",
			"int finitof() {",
			"    /* questa funzione verifica i valori memorizzati nell'array finito: ",
			"    appena trova un elemento uguale a 0 vuole dire che non tutti i processi ",
			"    figli sono finiti e quindi torna 0; tornera' 1 se e solo se tutti gli elementi ",
			"    dell'array sono a 1 e quindi tutti i processi sono finiti */",
			"",
			"    for (int i = 0; i < N; i++) {",
			"        if (!finito[i]) {",
			"            /* appena ne trova uno che non ha finito */",
			"            return 0; /* ritorna falso */",
			"        }",
			"    }",
			"    return 1;",
			"}",
			"",
			"int main(int argc, char const **argv) {",
			"    /* controllo numero parametri */",
			"    if (argc < 3) {",
			"        printf(\"Error: numero parametri '%d' errato\\n\", argc - 1);",
			"        printf(\"Uso: %s file1 file2 ...\\n\", argv[0]);",
			"        exit(1);",
			"    }",
			"",
			"    /* -------- Variabili locali ---------- */",
			"    int pid;                /* process identifier per le fork() */",
			"    pipe_t *pipedFP;        /* array dinamico di pipe descriptors per comunicazioni figli-padre */",
			"    pipe_t *pipedPF;        /* array dinamico di pipe descriptors per comunicazioni padre-figli */",
			"    int n, j;               /* indici per i cicli */",
			"    int pidWaitedSon, status, ritorno;/* per valore di ritorno dei vari processi (figli/nipoti) */",
			"    int fd;                 /* file descriptor */",
			"    char linea[255];        /* array di caratteri per memorizzare la linea, supponendo una lunghezza massima di ogni linea di 255 caratteri compreso il terminatore di linea */",
			"    char car;               /* variabile usata dal padre per leggere gli ultimi caratteri delle linee inviati dai figli */",
			"    char chMax;             /* variabile usata dal padre per tenere traccia del carattere di codice ASCII massimo */",
			"    char chControllo;       /* variabile per inviare indicazione ai figli */",
			"    int indice;             /* variabile usata dal padre per tenere traccia dell'indice del figlio che ha calcolato il massimo */",
			"    int stampe;             /* numero di stampe fatte dai figli che va ritornato al padre */",
			"    int nr, nw;             /* per controlli read e write su/da pipe */",
			"    /* ------------------------------------ */",
			"",
			"    /* Salvo il numero dei file in una variabile */",
			"    N = argc - 1; ",
			"",
			"    /* allocazione memoria dinamica per finito */",
			"    finito = (int *) malloc(sizeof(int) * N);",
			"    if(finito == NULL) {",
			"        printf(\"Errore nella allocazione della memoria per array finito\\n\");",
			"        exit(2);",
			"    }",
			"    /* ... e inizializzazione a 0: all'inizio nessun figlio e' finito */",
			"    memset(finito, 0, N * sizeof(int));",
			"",
			"    /* Alloco memoria per l'array delle pipe per la comunicazione figlio-padre */",
			"    if(!(pipedFP = (pipe_t*) malloc(N * sizeof(pipe_t)))) {",
			"        printf(\"Errore: Impossibile allocare memoria per l'array delle pipe per la comunicazione figlio-padre!\\n\");",
			"        exit(2);",
			"    }",
			"",
			"    /* Alloco memoria per l'array delle pipe per la comunicazione padre-figlio */",
			"    if(!(pipedPF = (pipe_t*) malloc(N * sizeof(pipe_t)))) {",
			"        printf(\"Errore: Impossibile allocare memoria per l'array delle pipe per la comunicazione padre-figlio!\\n\");",
			"        exit(3);",
			"    }",
			"",
			"    /* Creazione delle N pipe figli-padre e delle N pipe padre-figli */",
			"    for(n = 0; n < N; n++) {",
			"        if(pipe(pipedFP[n]) < 0) {",
			"            printf(\"Errore: Impossibile creare la pipe figlio-padre %d-esima!\\n\", n);",
			"            exit(4);",
			"        }",
			"        if(pipe(pipedPF[n]) < 0) {",
			"            printf(\"Errore: Impossibile creare la pipe padre-figlio %d-esima!\\n\", n);",
			"            exit(5);",
			"        }",
			"    }",
			"",
			"    printf(\"--------------------------\\n\");",
			"    printf(\"DEBUG: Sono il padre con pid=%d e sto per creare [%d] figli!\\n\", getpid(), N);",
			"    printf(\"--------------------------\\n\");",
			"",
			"    /* Creo N processi figli */",
			"    for(n = 0; n < N; n++) {",
			"",
			"        if((pid = fork()) < 0) {",
			"            printf(\"Errore: Impossibile creare il processo figlio %d-esimo!\\n\", n);",
			"            exit(6);",
			"        }",
			"",
			"        /* Codice del processo figlio */",
			"        if(pid == 0) {",
			"",
			"            /* Chiusura delle pipe non usate nella comunicazione con il padre */",
			"            for (j = 0; j < N; j++) {",
			"                close(pipedFP[j][0]);",
			"                close(pipedPF[j][1]);",
			"                if (n != j) {",
			"                    close(pipedFP[j][1]);",
			"                    close(pipedPF[j][0]);",
			"                }",
			"            }",
			"",
			"            /* Apro il file in sola lettura */",
			"            if((fd = open(argv[n + 1], O_RDONLY)) < 0) {",
			"                printf(\"Errore: Impossibile aprire il file %s in sola lettura!\\n\", argv[n + 1]);",
			"                exit(-1);",
			"            }",
			"",
			"            /* adesso il figlio legge dal file una linea alla volta */",
			"            j=0;",
			"            /* inizializziamo le stampe a 0 */",
			"            stampe = 0;",
			"",
			"            while(read(fd, &(linea[j]), 1)){",
			"                if(linea[j] == '\\n'){",
			"                    /* inviamo l'ultimo carattere (escluso il terminatore di linea) al padre, avendo ipotizzato che ogni file contenga SEMPRE per ogni linea almeno un carattere oltre il terminatore di linea*/",
			"",
			"                    nw = write(pipedFP[n][1], &linea[j - 1], 1);",
			"                    if(nw != 1){",
			"                        printf(\"Errore: impossibile scrivere il carattere %c sulla pipe figlio-padre %d-esima\\n\", linea[j - 1], n);",
			"                        exit(-1);",
			"                    }",
			"",
			"                    /* aspettiamo dal risposta da padre se stampare o meno */",
			"                    nr = read(pipedPF[n][0], &chControllo, 1);",
			"                    if(nr != 1){",
			"                        printf(\"Errore: impossibile leggere il carattere di controllo dalla pipe padre-figlio %d-esima\\n\", n);",
			"                        exit(-1);",
			"                    }",
			"",
			"                    if (chControllo == 'S') {",
			"                        ",
			"                        /* stampiamo la linea */",
			"                        linea[j + 1] = '\\0'; /* mettiamo il terminatore di stringa */",
			"                        printf(\"Sono il figlio di indice %d e pid %d e ho trovato una linea con un ultimo carattere '%c' con codice ASCII maggiore degli altri nel file %s. Ecco la linea:\\n%s\", n, getpid(), linea[j-1], argv[n+1], linea);",
			"                        stampe++; /* incrementiamo il contatore delle stampe */",
			"                    }",
			"",
			"                    j = 0; /* azzeriamo l'indice per le prossime linee */",
			"                } else {",
			"                    j++; /* incrementiamo l'indice per la prossima lettura */",
			"                }",
			"            }",
			"",
			"            exit(stampe); /* return del figlio al padre */",
			"        }",
			"    }",
			"",
			"    /* Codice del processo padre */",
			"",
			"    /* Il padre chiude n lati delle pipe che non usa */",
			"    for (n = 0; n < N; n++) {",
			"        close(pipedFP[n][1]);",
			"        close(pipedPF[n][0]);",
			"    }",
			"",
			"    /* continuiamo a ciclare su tutti i figli in ordine, finche' tutti non hanno finito */",
			"    while(!finitof()) {",
			"\t\tchMax = -1; /* ATTENZIONE: il valore del massimo, va resettato per ogni insieme di valori letti dal padre */",
			"\t\tfor (n = 0; n < N; n++) {",
			"\t\t    /* tentiamo di leggere il carattere dal figlio i-esimo: contestualmente viene aggiornato il valore del corrispondente elemento dell'array finito */",
			"\t\t    finito[n] = (read(pipedFP[n][0], &car, 1) != 1);  /* nel caso la read torni un valore diverso da 1, il corrispondente valore di finito viene settato a 1 dato che la condizione e' vera! */",
			"\t\t",
			"\t\t    if (!finito[n]) {",
			"\t\t        if (car > chMax) {",
			"\t\t            /* dobbiamo aggiornare il massimo */",
			"\t\t            chMax = car;",
			"\t\t            /* debbiamo tenere conto dell'indice del processo che ha inviato il massimo */",
			"\t\t            indice = n;",
			"\t\t        }",
			"\t\t    }",
			"\t\t}",
			"\t\t/* bisogna mandare ai figli l'indicazione giusta (S per scrivere, N per NON scrivere) */",
			"\t\tfor (n = 0; n < N; n++) {",
			"\t\t    if (n == indice) /* figlio che deve scrivere */",
			"\t\t        chControllo = 'S';",
			"\t\t    else chControllo = 'N';",
			"\t\t    if (!finito[n]) {",
			"\t\t        nw = write(pipedPF[n][1], &chControllo, 1); ",
			"\t\t        if (nw != 1) {",
			"\t\t            printf(\"PADRE non e' riuscito ad inviare nulla al figlio di indice %d \\n\", n);",
			"\t\t        }",
			"\t\t    }",
			"\t\t}",
			"        printf(\"DEBUG-PADRE valore della funzione finitof=%d\\n\", finitof());",
			"    }",
			"",
			"    /* Il padre aspetta i figli salvando lo status */",
			"    for (n = 0; n < N; n++) {",
			"        if ((pidWaitedSon = wait(&status)) < 0) {",
			"            printf(\"Errore in wait per il figlio %d-esimo!\\n\", n);",
			"            exit(5);",
			"        }",
			"        if ((status & 0xFF) != 0)",
			"            printf(\"Figlio %d-esimo con pid %d terminato in modo anomalo\\n\", n, pidWaitedSon);",
			"        else {",
			"            ritorno = (int)((status >> 8) & 0xFF);",
			"            printf(\"--------------------------\\n\");",
			"            printf(\"DEBUG: Il figlio %d-esimo con pid=%d ha ritornato %d (se 255 problemi)\\n\", n, pidWaitedSon, ritorno);",
			"            printf(\"--------------------------\\n\");",
			"        }",
			"    }",
			"",
			"    exit(0); /* return del padre al sistema */",
			"}"
		],
		"description": "pipeline figlio padre, padre figlio con while !finito"
	},
	"Ring tra i figli": {
		"prefix": "ringTraFigli",
		"body": [
			"/* File ${TM_FILENAME} */",
			"/* Standard C = C11 */",
			"",
			"#include <stdio.h> /* Standard I/O: printf, BUFSIZ */",
			"#include <fcntl.h> /* File CoNTrol: open, O_RDONLY, O_WRONLY, O_RDWR */",
			"#include <stdlib.h> /* STanDard LIBrary: exit, malloc, calloc, free, atoi */",
			"#include <unistd.h> /* UNIx Standard: read, write, close, SEEK_SET, SEEK_CUR, SEEK_END */",
			"#include <sys/wait.h> /* SYStem WAIT: wait */",
			"",
			"typedef int pipe_t[2]; /* Definizione di un tipo pipe_t come array di 2 interi */",
			"typedef char L[250]; /* Definizione di un tipo L come array di 250 caratteri */",
			"",
			"int main(int argc, char const **argv) {",
			"    /* controllo numero parametri */",
			"    if (argc < 3) {",
			"        printf(\"Error: numero parametri '%d' errato\\n\", argc - 1);",
			"        printf(\"Uso: %s file1 file2 ... fileN \\n\", argv[0]);",
			"        exit(1);",
			"    }",
			"",
			"    /* -------- Variabili locali ---------- */",
			"    int pid;                /* process identifier per le fork() */",
			"    int N;                  /* numero di file passati sulla riga di comando (uguale al numero di file) */",
			"    pipe_t *piped;          /* array dinamico di pipe descriptors per comunicazioni figli-padre  */",
			"    int n, i, j, k;               /* indici per i cicli */",
			"    int pidWaitedSon, status, ritorno;/* per valore di ritorno dei vari processi (figli/nipoti) */",
			"    int fd;              /* file descriptor */",
			"    int nr,nw;              /* variabili per salvare valori di ritorno di read/write da/su pipe */",
			"    int fdout;  /* file descriptor per la creazione del file */",
			"    L linea;    /* per salvare la linea letta */",
			"    L* tutteLinee; /* per salvare tutte le linee lette */",
			"    ",
			"    /* ------------------------------------ */",
			"",
			"    /* Salvo il numero dei file in una variabile */",
			"    N = argc - 1; ",
			"",
			"    /* Alloco memoria per l'array delle pipe per la comunicazione figlio-padre */",
			"    if(!(piped = (pipe_t*) malloc(N * sizeof(pipe_t)))) {",
			"        printf(\"Errore: Impossibile allocare memoria per l'array delle pipe per la comunicazione figlio-padre!\\n\");",
			"        exit(2);",
			"    }",
			"",
			"    /* Inizializzo l'array delle pipe */",
			"    for(n = 0; n < N; n++) {",
			"        if(pipe(piped[n]) < 0) {",
			"            printf(\"Errore: Impossibile inizializzare l'array delle pipe, si è bloccato alla pipe di indice: %d!\\n\", n);",
			"            exit(3);",
			"        }",
			"    }",
			"",
			"    /* allocazione dell'array delle linee */",
			"    if ((tutteLinee = (L *) malloc(N * sizeof(L))) == NULL) {",
			"        printf(\"Errore nell'allocazione dell'array delle linee\\n\");",
			"        exit(4);",
			"    }",
			"",
			"    printf(\"--------------------------\\n\");",
			"    printf(\"DEBUG: Sono il padre con pid=%d e sto per creare [%d] figli!\\n\", getpid(), N);",
			"    printf(\"--------------------------\\n\");",
			"",
			"    /* creazione file in cervinschi */",
			"    /* usato la open in versione estesa per azzerare il file nel caso esista gia' */",
			"    if ((fdout=creat(\"Cervinschi\", 0644)) < 0) {",
			"        printf(\"Errore nella creazione del file %s\\n\", \"cervinschi\");",
			"        exit(5);",
			"    }",
			"",
			"    /* Creo N processi figli */",
			"    for(n = 0; n < N; n++) {",
			"",
			"        if((pid = fork()) < 0) {",
			"            printf(\"Errore: Impossibile creare il processo figlio %d-esimo!\\n\", n);",
			"            exit(6);",
			"        }",
			"",
			"        /* Codice del processo figlio */",
			"        if(pid == 0) {",
			"",
			"            printf(\"--------------------------\\n\");",
			"            printf(\"DEBUG: Sono il figlio con pid=%d e indice %d, associato al file %s\\n\", getpid(), n, argv[n + 1]);",
			"            printf(\"--------------------------\\n\");",
			"            /* Chiudo tutte le pipe di non interesse */",
			"            for(j = 0; j < N; j++) {",
			"                if (j != n) {",
			"                    close(piped[j][0]);",
			"                }",
			"                if (j != (n + 1) % N) {",
			"                    close(piped[j][1]);",
			"                }",
			"            }",
			"",
			"            /* apertura file */",
			"            if ((fd = open(argv[n + 1], O_RDONLY)) < 0) {",
			"                printf(\"Impossibile aprire il file %s\\n\", argv[n + 1]);",
			"                exit(-1);",
			"            }",
			"",
			"            /* inizializziamo il contatore del carattere cercato per ogni singola linea */",
			"            j = 0;",
			"            /* con un ciclo leggiamo tutte le linee, come richiede la specifica */",
			"            while (read(fd, &(linea[j]), 1) != 0) {",
			"                if (linea[j] == '\\n') { /* siamo a fine linea */",
			"",
			"                    nr = read(piped[n][0], tutteLinee, N*sizeof(L));",
			"                    /* per sicurezza controlliamo il risultato della lettura da pipe */",
			"                    if (nr != N*sizeof(L)) {",
			"                        printf(\"Figlio %d ha letto un numero di byte sbagliati %d\\n\", n, nr);",
			"                        exit(-1);",
			"                    }",
			"",
			"                    /* insetiamo la linea letta al posto giusto */",
			"                    for (k = 0; k <= j; k++) {",
			"                        tutteLinee[n][k] = linea[k];",
			"                    }",
			"",
			"                    nw = write(piped[(n + 1)%N][1], tutteLinee, N*sizeof(L));",
			"                    /* anche in questo caso controlliamo il risultato della scrittura */",
			"                    if (nw != N*sizeof(L)) {",
			"                        printf(\"Figlio %d ha scritto un numero di byte sbagliati %d\\n\", n, nw);",
			"                        exit(-1);",
			"                    }",
			"",
			"                    if (n == N - 1) {",
			"                        /* se siamo all'ultimo figlio, scriviamo la linea su file */",
			"                        for (i = 0; i < N; i++) {",
			"                            for (k = 0; k < 250; k++) {",
			"                                write(fdout, &(tutteLinee[i][k]), 1);",
			"                                if (tutteLinee[i][k] == '\\n') {",
			"                                    break;",
			"                                }",
			"                            }",
			"                        }",
			"                    } ",
			"                    ritorno = j+1;",
			"                    j = 0;",
			"                } else {",
			"                    j++;",
			"                }",
			"            }",
			"            /* ogni figlio deve tornare il numero di caratteri numerici dell'ultima linea */",
			"            exit(ritorno); /* return del figlio al padre */",
			"        }",
			"    }",
			"",
			"    /* Codice del processo padre */",
			"",
			"    /* chiusura di tutte le pipe che non usa, a parte la prima e l'ultima */",
			"    for (n = 1; n < N; n++) {",
			"        close(piped[n][0]);",
			"        close(piped[n][1]);",
			"    }",
			"    /* Poiche' in questo caso il padre e' nel ring, non ci sono problemi di dover lasciare aperti lati di pipe che il padre non usa! */",
			"",
			"    /* mandiamo al primo figlio l'array delle linee */",
			"    nw = write(piped[0][1], tutteLinee, N*sizeof(L));",
			"    if (nw != N*sizeof(L)) {",
			"        printf(\"Padre ha scritto un numero di byte sbagliati %d\\n\", nw);",
			"        exit(7);",
			"    }",
			"",
			"    /* chiudiamo il lato di scrittura della pipe */",
			"    close(piped[0][1]);",
			"",
			"    ",
			"    /* Il padre aspetta i figli salvando lo status */",
			"    for (n = 0; n < N; n++) {",
			"        if ((pidWaitedSon = wait(&status)) < 0) {",
			"            printf(\"Errore in wait per il figlio %d-esimo!\\n\", n);",
			"            exit(8);",
			"        }",
			"        if ((status & 0xFF) != 0)",
			"            printf(\"Figlio %d-esimo con pid %d terminato in modo anomalo\\n\", n, pidWaitedSon);",
			"        else {",
			"            ritorno = (int)((status >> 8) & 0xFF);",
			"            printf(\"--------------------------\\n\");",
			"            printf(\"DEBUG: Il figlio %d-esimo con pid=%d ha ritornato %d (se 255 problemi)\\n\", n, pidWaitedSon, ritorno);",
			"            printf(\"--------------------------\\n\");",
			"        }",
			"    }",
			"",
			"    exit(0); /* return del padre al sistema */",
			"}"
		],
		"description": "Creazione di un ring tra i figli"
	},
	"Pipeline Padre comunica con il figlio che comunica con il nipote che esegue comandi shell": {
		"prefix": "padre->figlio->nipote->SH",
		"body": [
			"/* File ${TM_FILENAME} */",
			"/* Standard C = C11 */",
			"",
			"#include <stdio.h> /* Standard I/O: printf, BUFSIZ */",
			"#include <fcntl.h> /* File CoNTrol: open, O_RDONLY, O_WRONLY, O_RDWR */",
			"#include <stdlib.h> /* STanDard LIBrary: exit, malloc, calloc, free, atoi */",
			"#include <unistd.h> /* UNIx Standard: read, write, close, SEEK_SET, SEEK_CUR, SEEK_END */",
			"#include <sys/wait.h> /* SYStem WAIT: wait */",
			"#include <string.h> /* per la funzione strlen */",
			"#include <sys/stat.h> /* per la funzione open */",
			"",
			"typedef int pipe_t[2]; /* Definizione di un tipo pipe_t come array di 2 interi */",
			"",
			"int main(int argc, char const **argv) {",
			"    /* controllo numero parametri */",
			"    if (argc != 3) {",
			"        printf(\"Error: numero parametri '%d' errato\\n\", argc - 1);",
			"        printf(\"Uso: %s \\n\", argv[0]);",
			"        exit(1);",
			"    }",
			"",
			"    /* -------- Variabili locali ---------- */",
			"    int pid;                /* process identifier per le fork() */",
			"    int N;                  /* numero di file passati sulla riga di comando (uguale al numero di file) */",
			"    pipe_t *piped;          /* array dinamico di pipe descriptors per comunicazioni figli-padre  */",
			"    pipe_t p;/* una sola pipe per ogni coppia figlio-nipote */",
			"    int i, j;              /* indici per i cicli */",
			"    int pidWaitedSon, status, ritorno;/* per valore di ritorno dei vari processi (figli/nipoti) */",
			"    int fd;             /* file descriptor */",
			"    ",
			"    /* ------------------------------------ */",
			"",
			"",
			"    /* Salvo il numero dei file in una variabile */",
			"    N = argc - 1; ",
			"",
			"    /* Alloco memoria per l'array delle pipe per la comunicazione figlio-padre */",
			"    if(!(piped = (pipe_t*) malloc(N * sizeof(pipe_t)))) {",
			"        printf(\"Errore: Impossibile allocare memoria per l'array delle pipe per la comunicazione figlio-padre!\\n\");",
			"        exit(2);",
			"    }",
			"",
			"    /* Inizializzo l'array delle pipe */",
			"    for(i = 0; i < N; i++) {",
			"        if(pipe(piped[i]) < 0) {",
			"            printf(\"Errore: Impossibile inizializzare l'array delle pipe per il figlio %d-esimo!\\n\", i);",
			"            exit(3);",
			"        }",
			"    }",
			"",
			"    printf(\"--------------------------\\n\");",
			"    printf(\"DEBUG: Sono il padre con pid=%d e sto per creare [%d] figli!\\n\", getpid(), N);",
			"    printf(\"--------------------------\\n\");",
			"",
			"    /* Creo N processi figli */",
			"    for(i = 0; i < N; i++) {",
			"",
			"        if((pid = fork()) < 0) {",
			"            printf(\"Errore: Impossibile creare il processo figlio %d-esimo!\\n\", i);",
			"            exit(4);",
			"        }",
			"",
			"        /* Codice del processo figlio */",
			"        if(pid == 0) {",
			"",
			"            /* Chiudo tutte le pipe di non interesse */",
			"            for(j = 0; j < N; j++) {",
			"                close(piped[j][0]);",
			"                if(i != j) {",
			"                    close(piped[j][1]);",
			"                }",
			"            }",
			"",
			"            /* Creo la pipe per la comunicazione fra figlio e nipote */",
			"            if(pipe(p) < 0) {",
			"                printf(\"Errore: Impossibile creare la pipe per la comunicazione fra figlio %d-esimo e nipote!\\n\");",
			"                exit(-1);",
			"            }",
			"",
			"            /* Creo il processo nipote */",
			"            if((pid = fork()) < 0) {",
			"                printf(\"Errore: Impossibile creare il processo nipote!\\n\");",
			"                exit(-1);",
			"            }",
			"",
			"            /* Codice del processo nipote */",
			"            if(pid == 0) {",
			"                /* chiusura della pipe rimasta aperta di comunicazione fra figlio-padre che il nipote non usa */",
			"                close(piped[i][1]);",
			"",
			"                ",
			"                /* Ridirezione dello standard input: DA FARE SOLO SE RICHIEDE UN COMANDO-FILTRO*/",
			"                close(0);",
			"                if (open(argv[i + 1], O_RDONLY) < 0) {",
			"                    printf(\"Errore nella open del file %s\\n\", argv[i+1]);",
			"                    exit(-1); /* si veda commento precedente */",
			"                }",
			"                ",
			"                /* ogni nipote deve simulare il piping dei comandi nei confronti del figlio/padre e quindi deve chiudere lo standard output e quindi usare la dup sul lato di scrittura della propria pipe */",
			"                close(1);",
			"                dup(p[1]);             ",
			"",
			"                /* ogni nipote adesso puo' chiudere entrambi i lati della pipe: il lato 0 non viene usato e il lato 1 viene usato tramite lo standard output */",
			"                close(p[0]);",
			"                close(p[1]);",
			"",
			"                /* Ridirezione dello standard error su /dev/null (per evitare messaggi di errore a video) */",
			"                close(2);",
			"                open(\"/dev/null\", O_WRONLY);",
			"                ",
			"                /* Il nipote diventa il comando wc -l */        ",
			"                execlp( ...... , (char *)0);",
			"                ",
			"                /* Non si dovrebbe mai tornare qui!!*/",
			"                exit(-1); /* si veda commento precedente */",
			"            }",
			"",
			"            /* codice figlio */",
			"            /* ogni figlio deve chiudere il lato che non usa della pipe di comunicazione con il nipote */",
			"            close(p[1]);",
			"            ",
			"            /* adesso il figlio legge dalla pipe un carattere alla volta */",
			"            j=0;",
			"          ",
			"            while (read(p[0], &SOST, 1)) {",
			"                /* implementare richieste*/",
			"                j++;",
			"            }",
			"",
			"            /* il figlio comunica al padre */",
			"            write(piped[i][1], &SOST, sizeof(SOST));",
			"",
			"            /* il figlio deve aspettare il nipote per restituire il valore al padre */",
			"            /* se il nipote e' terminato in modo anomalo decidiamo di tornare -1 e verra' interpretato come 255 e quindi segnalando questo problema al padre */",
			"",
			"            ritorno = -1; /* valore di ritorno del nipote */",
			"            /* il figlio aspetta il nipote */",
			"            if ((pidWaitedSon = wait(&status)) < 0) {",
			"                printf(\"Errore in wait per il nipote %d-esimo con pid=%d!\\n\", i, getpid());",
			"            }",
			"            if ((status & 0xFF) != 0)",
			"                printf(\"Nipote con pid %d terminato in modo anomalo\\n\", pidWaitedSon);",
			"            else {",
			"                ritorno = (int)((status >> 8) & 0xFF);",
			"                printf(\"--------------------------\\n\");",
			"                printf(\"DEBUG: Il Nipote %d-esimo con pid=%d ha ritornato %d (se 255 problemi)\\n\", i, pidWaitedSon, ritorno);",
			"                printf(\"--------------------------\\n\");",
			"            }",
			"",
			"            exit(ritorno); /* return del figlio al padre */",
			"        }",
			"    }",
			"",
			"    /* Codice del processo padre */",
			"",
			"    /* Il padre chiude i lati delle pipe che non usa */",
			"    for (i=0; i < N; i++) {",
			"        close(piped[i][1]);",
			"    }",
			"",
			"    /* Il padre recupera le informazioni dai figli in ordine di indice */",
			"    for (i = 0; i < N; i++) {",
			"        read(piped[i][0], &SOST, sizeof(SOST));",
			"        printf(\"\", ...);",
			"    }",
			"",
			"    /* Il padre aspetta i figli salvando lo status */",
			"    for (int i = 0; i < N; i++) {",
			"        if ((pidWaitedSon = wait(&status)) < 0) {",
			"            printf(\"Errore in wait per il figlio %d-esimo!\\n\", i);",
			"            exit(7);",
			"        }",
			"        if ((status & 0xFF) != 0)",
			"            printf(\"Figlio %d-esimo con pid %d terminato in modo anomalo\\n\", i, pidWaitedSon);",
			"        else {",
			"            ritorno = (int)((status >> 8) & 0xFF);",
			"            printf(\"--------------------------\\n\");",
			"            printf(\"DEBUG: Il figlio %d-esimo con pid=%d ha ritornato %d (se 255 problemi)\\n\", i, pidWaitedSon, ritorno);",
			"            printf(\"--------------------------\\n\");",
			"        }",
			"    }",
			"",
			"    exit(0); /* return del padre al sistema */",
			"}"
		],
		"description": "Nipote comunica con il figlio che comunica con il padre + comando SH"
	},
	"EXECL example": {
		"prefix": "execl",
		"body": [
			"execl(\"/bin/ls\", \"ls\", \"-l\", (char *)0);"
		],
		"description": "execl example"
	},
	"EXECLP example": {
		"prefix": "execlp",
		"body": [
			"execlp(\"ls\", \"ls\", \"-l\", (char *)0);"
		],
		"description": "execlp example"
	},
	"EXECV example": {
		"prefix": "execv",
		"body": [
			"char *args[] = {\"ls\", \"-l\", (char *)0};",
			"execv(\"/bin/ls\", args);"
		],
		"description": "execv example"
	},
	"EXECVP example": {
		"prefix": "execvp",
		"body": [
			"char *args[] = {\"ls\", \"-l\", (char *)0};",
			"execvp(\"ls\", args);"
		],
		"description": "execvp example"
	},
	"EXECVE example": {
		"prefix": "execve",
		"body": [
			"char *args[] = {\"ls\", \"-l\", (char *)0};",
			"char *env[] = {\"HOME=/\", \"LOGNAME=home\", (char *)0};",
			"execve(\"/bin/ls\", args, env);"
		],
		"description": "execve example"
	},
	"EXECLE example": {
		"prefix": "execle",
		"body": [
			"char *args[] = {\"ls\", \"-l\", (char *)0};",
			"char *env[] = {\"HOME=/\", \"LOGNAME=home\", (char *)0};",
			"execle(\"/bin/ls\", \"ls\", \"-l\", (char *)0, env);"
		],
		"description": "execle example"
	},
	"EXECVPE example": {
		"prefix": "execvpe",
		"body": [
			"char *args[] = {\"ls\", \"-l\", (char *)0};",
			"char *env[] = {\"HOME=/\", \"LOGNAME=home\", (char *)0};",
			"execvpe(\"ls\", args, env);"
		],
		"description": "execvpe example"
	},
	"Ridirezione dello stdin su /dev/null": {
		"prefix": "stdin->/dev/null",
		"body": [
			"/* Ridirezione dello stdin su /dev/null */",
			"close(0);",
			"open(\"/dev/null\", O_RDONLY);"
		],
		"description": "Ridirezione dello stdin su /dev/null"
	},
	"Ridirezione dello stdout su /dev/null": {
		"prefix": "stdout->/dev/null",
		"body": [
			"/* Ridirezione dello stdout su /dev/null */",
			"close(1);",
			"open(\"/dev/null\", O_WRONLY);"
		],
		"description": "Ridirezione dello stdout su /dev/null"
	},
	"Ridirezione dello stderr su /dev/null": {
		"prefix": "stderr->/dev/null",
		"body": [
			"/* Ridirezione dello stderr su /dev/null */",
			"close(2);",
			"open(\"/dev/null\", O_WRONLY);"
		],
		"description": "Ridirezione dello stderr su /dev/null"
	},
	"Pipeline figlio parla con il figlio, l'ultimo con il padre, il figlio crea nipote e usa comando sh": {
		"prefix": "nipote(sh)->figlio->figlio->padre",
		"body": [
			"/* File main.c */",
			"/* Standard C = C11 */",
			"",
			"#include <stdio.h> /* Standard I/O: printf, BUFSIZ */",
			"#include <fcntl.h> /* File CoNTrol: open, O_RDONLY, O_WRONLY, O_RDWR */",
			"#include <stdlib.h> /* STanDard LIBrary: exit, malloc, calloc, free, atoi */",
			"#include <unistd.h> /* UNIx Standard: read, write, close, SEEK_SET, SEEK_CUR, SEEK_END */",
			"#include <sys/wait.h> /* SYStem WAIT: wait */",
			"#include <string.h> /* STRING: strlen, strcpy */",
			"",
			"typedef int pipe_t[2]; /* Definizione di un tipo pipe_t come array di 2 interi */",
			"",
			"typedef struct{",
			"    char c1[12];    /* deve contenere la stringa TROVATA o NON TROVATA*/",
			"    int c2; /* deve contenere il pid del processo nipote */",
			"} Strut;",
			"/* ATTENZIONE 'Strut' variabile del testo */",
			"",
			"int main(int argc, char const **argv) {",
			"    /* controllo numero parametri */",
			"    if (argc < 4) {",
			"        printf(\"Error: numero parametri '%d' errato\\n\", argc);",
			"        printf(\"Uso: %s file stringa1 stringa2 -opt[.. stringaN] \\n\", argv[0]);",
			"        exit(1);",
			"    }",
			"",
			"    /* dato che in questo caso il programma viene chiamato dalla parte shell siamo sicuri sulla validità dei parametri */",
			"",
			"    /* -------- Variabili locali ---------- */",
			"    int pid;               /* l'array di process identifier per le fork() */",
			"    int N;                /* numero di file passati sulla riga di comando (uguale al numero di file) */",
			"    /* ATTENZIONE 'N' variabile del testo */",
			"    pipe_t *piped;         /* array dinamico di pipe descriptors per comunicazioni figli-padre  */",
			"    int n, j;            /* indici per i cicli */",
			"    /* ATTENZIONE 'n' variabile del testo */",
			"    int pidWaitedSon, status, ritorno;/* per valore di ritorno dei vari processi (figli/nipoti) */",
			"    int nr,nw;/* variabili per salvare valori di ritorno di read e write da/su pipe */",
			"    Strut* cur;                            /* l'array di strutture da usare nei figli e nipoti */",
			"    /* ATTENZIONE 'cur' variabile del testo */",
			"    /* ------------------------------------ */",
			"",
			"    /* Salvo il numero dei file in una variabile */",
			"    N = argc - 2; /* argc - 2 perche' il primo parametro e' il file e gli altri N i processi da creare*/ ",
			"",
			"    /* Alloco memoria per l'array delle pipe per la comunicazione figlio-padre */",
			"    if(!(piped = (pipe_t*) malloc(N * sizeof(pipe_t)))) {",
			"        printf(\"Errore: Impossibile allocare memoria per l'array delle pipe per la comunicazione figlio-padre!\\n\");",
			"        exit(2);",
			"    }",
			"",
			"    /* Inizializzo l'array delle pipe */",
			"    for(n = 0; n < N; n++) {",
			"        if(pipe(piped[n]) < 0) {",
			"            printf(\"Errore: Impossibile inizializzare l'array delle pipe, si è bloccato alla pipe di indice: %d!\\n\", n);",
			"            exit(3);",
			"        }",
			"    }",
			"",
			"    printf(\"--------------------------\\n\");",
			"    printf(\"DEBUG: Sono il padre con pid=%d e sto per creare [%d] figli!\\n\", getpid(), N);",
			"    printf(\"--------------------------\\n\");",
			"",
			"    /* Creo N processi figli */",
			"    for(n = 0; n < N; n++) {",
			"",
			"        if((pid = fork()) < 0) {",
			"            printf(\"Errore: Impossibile creare il processo figlio %d-esimo!\\n\", n);",
			"            exit(4);",
			"        }",
			"",
			"        /* Codice del processo figlio */",
			"        if(pid == 0) {",
			"",
			"            printf(\"***********************\\n\");",
			"            printf(\"DEBUG: Sono il figlio %d-esimo con pid=%d associato alla stringa '%s'\\n\", n, getpid(), argv[n+2]);",
			"            printf(\"***********************\\n\");",
			"",
			"            /* Chiudo tutte le pipe di non interesse */",
			"            for(j = 0; j < N; j++) {",
			"                if (j != n) {",
			"                    close(piped[j][1]);",
			"                }",
			"                if ((n == 0) || (j != n-1)) {",
			"                    close(piped[j][0]);",
			"                }",
			"            }",
			"",
			"            /* creazione del nipote */",
			"            if((pid = fork()) < 0) {",
			"                printf(\"Errore: Impossibile creare il processo nipote %d-esimo!\\n\", n);",
			"                exit(-1);",
			"            }",
			"",
			"            /* Codice del processo nipote */",
			"            if (pid == 0) {",
			"",
			"                /* Codice del nipote */",
			"                printf(\"#####################################\\n\");",
			"                printf(\"Sono il nipote %d-esimo con pid=%d associato anche io alla stringa '%s'\\n\", n, getpid(), argv[n+2]);",
			"                printf(\"#####################################\\n\");",
			"",
			"                /* Chiusura degli unici lati di pipe rimasti aperti: il nipote non usa le pipe! */",
			"                close(piped[n][1]);",
			"                if (n != 0) {",
			"                    close(piped[n-1][0]);",
			"                }",
			"",
			"                /* Ridirezione dello stdout su /dev/null */",
			"                close(1);",
			"                open(\"/dev/null\", O_WRONLY);",
			"",
			"                /* Ridirezione dello stderr su /dev/null */",
			"                close(2);",
			"                open(\"/dev/null\", O_WRONLY);",
			"",
			"                /* cerco la stringa nel file */",
			"                execlp(\"grep\", \"grep\", argv[n + 2], argv[1], (char *)0);",
			"",
			"                /* se sono qui c'è stato un errore */",
			"                printf(\"Errore in execlp di grep\\n\");",
			"",
			"                exit(-1); /* torno un valore diverso da zero per indicare insuccesso*/",
			"            }",
			"",
			"            /* Codice del processo figlio */",
			"            /* allocazione dell'array di strutture specifico di questo figlio */",
			"            /* creiamo un array di dimensione n+1 anche se leggeremo n strutture, dato che poi ci servira' riempire la n+1-esima struttura! */",
			"            if ((cur = (Strut *)malloc((n + 1) * sizeof(Strut))) == NULL) {",
			"                printf(\"Errore allocazione cur\\n\");",
			"                exit(-1);",
			"            }",
			"            /* lettura da pipe dell'array di strutture per tutti i figli a parte il primo */",
			"            if (n != 0) {",
			"                nr = read(piped[n - 1][0], cur, n * sizeof(Strut));",
			"                if (nr != n * sizeof(Strut)) {",
			"                    printf(\"Figlio %d ha letto un numero di strutture sbagliate %d\\n\", n, nr);",
			"                    exit(-1);",
			"                }",
			"            }",
			"            /* inizializziamo l'ultima struttura che e' quella specifica del figlio corrente (nel caso del primo figlio sara' l'unica struttura */",
			"            cur[n].c2 = pid;",
			"",
			"            ritorno = 1;",
			"",
			"            /* Aspettiamo la fine del nipote/grep */",
			"            pid = wait(&status);",
			"            if (pid < 0) {",
			"                printf(\"Errore in wait\\n\");",
			"                /* si decide di mandare la stringa NON TROVATA al padre e tornare il valore 1 */",
			"                strcpy(cur[n].c1, \"NON TROVATA\");",
			"            }",
			"",
			"            if ((status & 0xFF) != 0) {",
			"                printf(\"Nipote terminato in modo involontario\\n\");",
			"                /* si decide di mandare la stringa NON TROVATA al padre e tornare il valore 1 */",
			"                strcpy(cur[n].c1, \"NON TROVATA\");",
			"            } else {",
			"                /* recupero il suo codice di ritorno */",
			"                ritorno = (status >> 8) & 0xFF;",
			"                if (ritorno == 0) { /* stringa trovata */",
			"                    strcpy(cur[n].c1, \"TROVATA\");",
			"                } else {",
			"                    strcpy(cur[n].c1, \"NON TROVATA\");",
			"                }",
			"            }",
			"",
			"            /* tutti i figli mandano in avanti, l'ultimo figlio manda al padre un array di strutture (per tutti i figli a parte il primo sono i strutture ricevute dal processo precedente e la i+1-esima che e' la propria) */",
			"            nw = write(piped[n][1], cur, (n + 1) * sizeof(Strut));",
			"            if (nw != (n + 1) * sizeof(Strut)) {",
			"                printf(\"Figlio %d ha scritto un numero di strutture sbagliate %d\\n\", n, nr);",
			"                exit(-1);",
			"            }",
			"",
			"            exit(ritorno); /* fine codice del figlio */",
			"        }",
			"    }",
			"",
			"    /* Codice del processo padre */",
			"",
			"    /* Chiudo tutte le pipe di non interesse */",
			"    for(n = 0; n < N; n++) {",
			"        close(piped[n][1]);",
			"        if (n != N-1)",
			"            close(piped[n][0]);",
			"    }",
			"",
			"    /* allocazione dell'array di strutture specifico per il padre */",
			"    /* creiamo un array di dimensione N quanto il numero di figli! */",
			"    if ((cur = (Strut *)malloc(N * sizeof(Strut))) == NULL) {",
			"        printf(\"Errore allocazione cur nel padre\\n\");",
			"        exit(5);",
			"    }",
			"",
			"    /* il padre deve leggere l'array di strutture che gli arriva dall'ultimo figlio */",
			"    nr = read(piped[N - 1][0], cur, N * sizeof(Strut));",
			"    if (nr != N * sizeof(Strut)) {",
			"        printf(\"Padre ha letto un numero di strutture sbagliate %d\\n\", nr);",
			"        exit(6);",
			"    }",
			"    printf(\"--------------------------\\n\");",
			"    printf(\"DEBUG-Padre ha letto un numero %d di strutture\\n\", N);",
			"    printf(\"--------------------------\\n\");",
			"    /* il padre deve stampare i campi delle strutture ricevute */",
			"    for (n = 0; n < N; n++) {",
			"        if (strcmp(cur[n].c1, \"TROVATA\") == 0) {",
			"            printf(\"Il figlio di indice %d ha generato un nipote con pid %d che ha trovato la stringa %s nel file %s\\n\", n, cur[n].c2, argv[n + 2], argv[1]);",
			"        } else {",
			"            printf(\"Il figlio di indice %d ha generato un nipote con pid %d che NON ha trovato la stringa %s nel file %s\\n\", n, cur[n].c2, argv[n + 2], argv[1]);",
			"        }",
			"    }",
			"",
			"    /* Il padre aspetta i figli salvando lo status */",
			"    for (n = 0; n < N; n++) {",
			"        if ((pidWaitedSon = wait(&status)) < 0) {",
			"            printf(\"Errore in wait per il figlio %d-esimo!\\n\", n);",
			"            exit(7);",
			"        }",
			"        if ((status & 0xFF) != 0)",
			"            printf(\"Figlio %d-esimo con pid %d terminato in modo anomalo\\n\", n, pidWaitedSon);",
			"        else {",
			"            ritorno = (int)((status >> 8) & 0xFF);",
			"            printf(\"--------------------------\\n\");",
			"            printf(\"DEBUG: Il figlio %d-esimo con pid=%d ha ritornato %d (se 255 problemi)\\n\", n, pidWaitedSon, ritorno);",
			"            printf(\"--------------------------\\n\");",
			"        }",
			"    }",
			"",
			"    exit(0); /* return del padre al sistema */",
			"}"
		],
		"description": "Pipeline figlio parla con il figlio, l'ultimo con il padre, il figlio crea nipote e usa comando sh"
	}
}